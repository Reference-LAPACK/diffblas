!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
!
!  Differentiation of snrm2 in reverse (adjoint) mode (with options multiDirectional):
!   gradient     of useful results: snrm2
!   with respect to varying inputs: x
!   RW status of diff variables: snrm2:in-killed x:out
!> \brief \b SNRM2
!
!  =========== DOCUMENTATION ===========
!
! Online html documentation available at
!            http://www.netlib.org/lapack/explore-html/
!
!  Definition:
!  ===========
!
!       REAL FUNCTION SNRM2(N,X,INCX)
!
!       .. Scalar Arguments ..
!       INTEGER INCX,N
!       ..
!       .. Array Arguments ..
!       REAL X(*)
!       ..
!
!
!> \par Purpose:
!  =============
!>
!> \verbatim
!>
!> SNRM2 returns the euclidean norm of a vector via the function
!> name, so that
!>
!>    SNRM2 := sqrt( x'*x ).
!> \endverbatim
!
!  Arguments:
!  ==========
!
!> \param[in] N
!> \verbatim
!>          N is INTEGER
!>         number of elements in input vector(s)
!> \endverbatim
!>
!> \param[in] X
!> \verbatim
!>          X is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
!> \endverbatim
!>
!> \param[in] INCX
!> \verbatim
!>          INCX is INTEGER, storage spacing between elements of X
!>          If INCX > 0, X(1+(i-1)*INCX) = x(i) for 1 <= i <= n
!>          If INCX < 0, X(1-(n-i)*INCX) = x(i) for 1 <= i <= n
!>          If INCX = 0, x isn't a vector so there is no need to call
!>          this subroutine.  If you call it anyway, it will count x(1)
!>          in the vector norm N times.
!> \endverbatim
!
!  Authors:
!  ========
!
!> \author Edward Anderson, Lockheed Martin
!
!> \date August 2016
!
!> \ingroup nrm2
!
!> \par Contributors:
!  ==================
!>
!> Weslley Pereira, University of Colorado Denver, USA
!
!> \par Further Details:
!  =====================
!>
!> \verbatim
!>
!>  Anderson E. (2017)
!>  Algorithm 978: Safe Scaling in the Level 1 BLAS
!>  ACM Trans Math Softw 44:1--28
!>  https://doi.org/10.1145/3061665
!>
!>  Blue, James L. (1978)
!>  A Portable Fortran Program to Find the Euclidean Norm of a Vector
!>  ACM Trans Math Softw 4:15--23
!>  https://doi.org/10.1145/355769.355771
!>
!> \endverbatim
!>
!  =====================================================================
SUBROUTINE SNRM2_BV(n, x, xb, incx, snrm2b, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
  INTEGER, PARAMETER :: wp=KIND(1.e0)
  REAL(wp) :: snrm2
  REAL(wp), DIMENSION(nbdirsmax) :: snrm2b
!
!  -- Reference BLAS level1 routine (version 3.9.1) --
!  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
!     March 2021
!
!  .. Constants ..
  REAL(wp), PARAMETER :: zero=0.0_wp
  REAL(wp), PARAMETER :: one=1.0_wp
  INTRINSIC HUGE
  REAL(wp), PARAMETER :: maxn=HUGE(0.0_wp)
  INTRINSIC RADIX
  INTRINSIC MINEXPONENT
  INTRINSIC REAL
  INTRINSIC CEILING
!  ..
!  .. Blue's scaling constants ..
  REAL(wp), PARAMETER :: tsml=REAL(RADIX(0._wp), wp)**CEILING((&
&   MINEXPONENT(0._wp)-1)*0.5_wp)
  INTRINSIC DIGITS
  INTRINSIC FLOOR
  INTRINSIC MAXEXPONENT
  REAL(wp), PARAMETER :: tbig=REAL(RADIX(0._wp), wp)**FLOOR((MAXEXPONENT&
&   (0._wp)-DIGITS(0._wp)+1)*0.5_wp)
  REAL(wp), PARAMETER :: ssml=REAL(RADIX(0._wp), wp)**(-FLOOR((&
&   MINEXPONENT(0._wp)-DIGITS(0._wp))*0.5_wp))
  REAL(wp), PARAMETER :: sbig=REAL(RADIX(0._wp), wp)**(-CEILING((&
&   MAXEXPONENT(0._wp)+DIGITS(0._wp)-1)*0.5_wp))
!  ..
!  .. Scalar Arguments ..
  INTEGER :: incx, n
!  ..
!  .. Array Arguments ..
  REAL(wp) :: x(*)
  REAL(wp) :: xb(nbdirsmax, *)
!  ..
!  .. Local Scalars ..
  INTEGER :: i, ix
  LOGICAL :: notbig
  REAL(wp) :: abig, amed, asml, ax, scl, sumsq, ymax, ymin
  REAL(wp), DIMENSION(nbdirsmax) :: abigb, amedb, asmlb, axb, sumsqb, &
& ymaxb, yminb
  INTRINSIC ABS
  INTRINSIC SQRT
  INTEGER :: nd
  REAL(wp) :: temp
  REAL(wp), DIMENSION(nbdirsmax) :: tempb
  INTEGER*4 :: branch
  INTEGER :: nbdirs
!
!  Quick return if possible
!
! Check 0 < nbdirs <= nbdirsmax (required by DIFFSIZES.inc)
  IF (nbdirs <= 0 .OR. nbdirs > nbdirsmax) THEN
    WRITE(*,'(A,I0,A,I0,A)') 'Error: nbdirs=', nbdirs, &
      ' must be in 1..nbdirsmax=', nbdirsmax, '. Stopping.'
    STOP 1
  END IF
!
  IF (n .LE. 0) THEN
    xb(1:nbdirsmax, 1:1+(n-1)*abs(incx)) = 0.0_4
  ELSE
!
!
!  Compute the sum of squares in 3 accumulators:
!     abig -- sums of squares scaled down to avoid overflow
!     asml -- sums of squares scaled up to avoid underflow
!     amed -- sums of squares that do not require scaling
!  The thresholds and multipliers are
!     tbig -- values bigger than this are scaled down by sbig
!     tsml -- values smaller than this are scaled up by ssml
!
    notbig = .true.
    asml = zero
    amed = zero
    abig = zero
    ix = 1
    IF (incx .LT. 0) ix = 1 - (n-1)*incx
    DO i=1,n
      IF (x(ix) .GE. 0.) THEN
        CALL PUSHREAL4(ax)
        ax = x(ix)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL4(ax)
        ax = -x(ix)
        CALL PUSHCONTROL1B(1)
      END IF
      IF (ax .GT. tbig) THEN
        abig = abig + (ax*sbig)**2
        notbig = .false.
        CALL PUSHCONTROL2B(0)
      ELSE IF (ax .LT. tsml) THEN
        IF (notbig) THEN
          asml = asml + (ax*ssml)**2
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      ELSE
        amed = amed + ax**2
        CALL PUSHCONTROL2B(3)
      END IF
      CALL PUSHINTEGER4(ix)
      ix = ix + incx
    END DO
!
!  Combine abig and amed or amed and asml if more than one
!  accumulator was used.
!
    IF (abig .GT. zero) THEN
!
!     Combine abig and amed if abig > 0.
!
      IF ((amed .GT. zero .OR. amed .GT. maxn) .OR. amed .NE. amed) THEN
        abig = abig + amed*sbig*sbig
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      scl = one/sbig
      sumsq = abig
      CALL PUSHCONTROL2B(0)
    ELSE IF (asml .GT. zero) THEN
!
!     Combine amed and asml if asml > 0.
!
      IF ((amed .GT. zero .OR. amed .GT. maxn) .OR. amed .NE. amed) THEN
        CALL PUSHREAL4(amed)
        amed = SQRT(amed)
        CALL PUSHREAL4(asml)
        asml = SQRT(asml)/ssml
        IF (asml .GT. amed) THEN
          ymin = amed
          ymax = asml
          CALL PUSHCONTROL1B(0)
        ELSE
          ymin = asml
          ymax = amed
          CALL PUSHCONTROL1B(1)
        END IF
        scl = one
        sumsq = ymax**2*(one+(ymin/ymax)**2)
        CALL PUSHCONTROL2B(1)
      ELSE
        scl = one/ssml
        sumsq = asml
        CALL PUSHCONTROL2B(2)
      END IF
    ELSE
!
!     Otherwise all values are mid-range
!
      scl = one
      sumsq = amed
      CALL PUSHCONTROL2B(3)
    END IF
    DO nd=1,nbdirs
      IF (sumsq .EQ. 0.0) THEN
        sumsqb(nd) = 0.0_4
      ELSE
        sumsqb(nd) = scl*snrm2b(nd)/(2.0*SQRT(sumsq))
      END IF
    END DO
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO nd=1,nbdirs
          abigb(nd) = sumsqb(nd)
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO nd=1,nbdirs
            amedb(nd) = sbig**2*abigb(nd)
          END DO
        ELSE
          amedb = 0.0_4
        END IF
        asmlb = 0.0_4
        GOTO 100
      ELSE
        temp = ymin/ymax
        DO nd=1,nbdirs
          tempb(nd) = 2*temp*ymax*sumsqb(nd)
          ymaxb(nd) = 2*ymax*(one+temp**2)*sumsqb(nd) - temp*tempb(nd)
          yminb(nd) = tempb(nd)
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO nd=1,nbdirs
            asmlb(nd) = ymaxb(nd)
            amedb(nd) = yminb(nd)
          END DO
        ELSE
          DO nd=1,nbdirs
            amedb(nd) = ymaxb(nd)
            asmlb(nd) = yminb(nd)
          END DO
        END IF
        CALL POPREAL4(asml)
        CALL POPREAL4(amed)
        DO nd=1,nbdirs
          IF (asml .EQ. 0.0) THEN
            asmlb(nd) = 0.0_4
          ELSE
            asmlb(nd) = asmlb(nd)/(2.0*SQRT(asml)*ssml)
          END IF
          IF (amed .EQ. 0.0) THEN
            amedb(nd) = 0.0_4
          ELSE
            amedb(nd) = amedb(nd)/(2.0*SQRT(amed))
          END IF
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      DO nd=1,nbdirs
        asmlb(nd) = sumsqb(nd)
      END DO
      amedb = 0.0_4
    ELSE
      DO nd=1,nbdirs
        amedb(nd) = sumsqb(nd)
      END DO
      asmlb = 0.0_4
    END IF
    abigb = 0.0_4
 100 xb(1:nbdirsmax, 1:1+(n-1)*abs(incx)) = 0.0_4
    DO i=n,1,-1
      CALL POPINTEGER4(ix)
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          DO nd=1,nbdirs
            axb(nd) = sbig**2*2*ax*abigb(nd)
          END DO
        ELSE
          DO nd=1,nbdirs
            axb(nd) = ssml**2*2*ax*asmlb(nd)
          END DO
        END IF
      ELSE IF (branch .EQ. 2) THEN
        axb = 0.0_4
      ELSE
        DO nd=1,nbdirs
          axb(nd) = 2*ax*amedb(nd)
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4(ax)
        DO nd=1,nbdirs
          xb(nd, ix) = xb(nd, ix) + axb(nd)
        END DO
      ELSE
        CALL POPREAL4(ax)
        DO nd=1,nbdirs
          xb(nd, ix) = xb(nd, ix) - axb(nd)
        END DO
      END IF
    END DO
  END IF
END SUBROUTINE SNRM2_BV

