!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
!
!  Differentiation of dnrm2 in reverse (adjoint) mode:
!   gradient     of useful results: dnrm2
!   with respect to varying inputs: x
!   RW status of diff variables: x:out dnrm2:in-killed
!> \brief \b DNRM2
!
!  =========== DOCUMENTATION ===========
!
! Online html documentation available at
!            http://www.netlib.org/lapack/explore-html/
!
!  Definition:
!  ===========
!
!       DOUBLE PRECISION FUNCTION DNRM2(N,X,INCX)
!
!       .. Scalar Arguments ..
!       INTEGER INCX,N
!       ..
!       .. Array Arguments ..
!       DOUBLE PRECISION X(*)
!       ..
!
!
!> \par Purpose:
!  =============
!>
!> \verbatim
!>
!> DNRM2 returns the euclidean norm of a vector via the function
!> name, so that
!>
!>    DNRM2 := sqrt( x'*x )
!> \endverbatim
!
!  Arguments:
!  ==========
!
!> \param[in] N
!> \verbatim
!>          N is INTEGER
!>         number of elements in input vector(s)
!> \endverbatim
!>
!> \param[in] X
!> \verbatim
!>          X is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
!> \endverbatim
!>
!> \param[in] INCX
!> \verbatim
!>          INCX is INTEGER, storage spacing between elements of X
!>          If INCX > 0, X(1+(i-1)*INCX) = x(i) for 1 <= i <= n
!>          If INCX < 0, X(1-(n-i)*INCX) = x(i) for 1 <= i <= n
!>          If INCX = 0, x isn't a vector so there is no need to call
!>          this subroutine.  If you call it anyway, it will count x(1)
!>          in the vector norm N times.
!> \endverbatim
!
!  Authors:
!  ========
!
!> \author Edward Anderson, Lockheed Martin
!
!> \date August 2016
!
!> \ingroup nrm2
!
!> \par Contributors:
!  ==================
!>
!> Weslley Pereira, University of Colorado Denver, USA
!
!> \par Further Details:
!  =====================
!>
!> \verbatim
!>
!>  Anderson E. (2017)
!>  Algorithm 978: Safe Scaling in the Level 1 BLAS
!>  ACM Trans Math Softw 44:1--28
!>  https://doi.org/10.1145/3061665
!>
!>  Blue, James L. (1978)
!>  A Portable Fortran Program to Find the Euclidean Norm of a Vector
!>  ACM Trans Math Softw 4:15--23
!>  https://doi.org/10.1145/355769.355771
!>
!> \endverbatim
!>
!  =====================================================================
SUBROUTINE DNRM2_B(n, x, xb, incx, dnrm2b)
  IMPLICIT NONE
  INTRINSIC KIND
  INTEGER, PARAMETER :: wp=KIND(1.d0)
  REAL(wp) :: dnrm2
  REAL(wp) :: dnrm2b
!
!  -- Reference BLAS level1 routine (version 3.9.1) --
!  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
!     March 2021
!
!  .. Constants ..
  REAL(wp), PARAMETER :: zero=0.0_wp
  REAL(wp), PARAMETER :: one=1.0_wp
  INTRINSIC HUGE
  REAL(wp), PARAMETER :: maxn=HUGE(0.0_wp)
  INTRINSIC RADIX
  INTRINSIC MINEXPONENT
  INTRINSIC REAL
  INTRINSIC CEILING
!  ..
!  .. Blue's scaling constants ..
  REAL(wp), PARAMETER :: tsml=REAL(RADIX(0._wp), wp)**CEILING((&
&   MINEXPONENT(0._wp)-1)*0.5_wp)
  INTRINSIC DIGITS
  INTRINSIC FLOOR
  INTRINSIC MAXEXPONENT
  REAL(wp), PARAMETER :: tbig=REAL(RADIX(0._wp), wp)**FLOOR((MAXEXPONENT&
&   (0._wp)-DIGITS(0._wp)+1)*0.5_wp)
  REAL(wp), PARAMETER :: ssml=REAL(RADIX(0._wp), wp)**(-FLOOR((&
&   MINEXPONENT(0._wp)-DIGITS(0._wp))*0.5_wp))
  REAL(wp), PARAMETER :: sbig=REAL(RADIX(0._wp), wp)**(-CEILING((&
&   MAXEXPONENT(0._wp)+DIGITS(0._wp)-1)*0.5_wp))
!  ..
!  .. Scalar Arguments ..
  INTEGER :: incx, n
!  ..
!  .. Array Arguments ..
  REAL(wp) :: x(*)
  REAL(wp) :: xb(*)
!  ..
!  .. Local Scalars ..
  INTEGER :: i, ix
  LOGICAL :: notbig
  REAL(wp) :: abig, amed, asml, ax, scl, sumsq, ymax, ymin
  REAL(wp) :: abigb, amedb, asmlb, axb, sumsqb, ymaxb, yminb
  INTRINSIC ABS
  INTRINSIC SQRT
  REAL(wp) :: temp
  REAL(wp) :: tempb
  INTEGER*4 :: branch
!
!  Quick return if possible
!
  IF (n .LE. 0) THEN
    xb(1:1+(n-1)*abs(incx)) = 0.0_8
  ELSE
!
!
!  Compute the sum of squares in 3 accumulators:
!     abig -- sums of squares scaled down to avoid overflow
!     asml -- sums of squares scaled up to avoid underflow
!     amed -- sums of squares that do not require scaling
!  The thresholds and multipliers are
!     tbig -- values bigger than this are scaled down by sbig
!     tsml -- values smaller than this are scaled up by ssml
!
    notbig = .true.
    asml = zero
    amed = zero
    abig = zero
    ix = 1
    IF (incx .LT. 0) ix = 1 - (n-1)*incx
    DO i=1,n
      IF (x(ix) .GE. 0.) THEN
        CALL PUSHREAL8(ax)
        ax = x(ix)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(ax)
        ax = -x(ix)
        CALL PUSHCONTROL1B(1)
      END IF
      IF (ax .GT. tbig) THEN
        abig = abig + (ax*sbig)**2
        notbig = .false.
        CALL PUSHCONTROL2B(0)
      ELSE IF (ax .LT. tsml) THEN
        IF (notbig) THEN
          asml = asml + (ax*ssml)**2
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      ELSE
        amed = amed + ax**2
        CALL PUSHCONTROL2B(3)
      END IF
      CALL PUSHINTEGER4(ix)
      ix = ix + incx
    END DO
!
!  Combine abig and amed or amed and asml if more than one
!  accumulator was used.
!
    IF (abig .GT. zero) THEN
!
!     Combine abig and amed if abig > 0.
!
      IF ((amed .GT. zero .OR. amed .GT. maxn) .OR. amed .NE. amed) THEN
        abig = abig + amed*sbig*sbig
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      scl = one/sbig
      sumsq = abig
      CALL PUSHCONTROL2B(0)
    ELSE IF (asml .GT. zero) THEN
!
!     Combine amed and asml if asml > 0.
!
      IF ((amed .GT. zero .OR. amed .GT. maxn) .OR. amed .NE. amed) THEN
        CALL PUSHREAL8(amed)
        amed = SQRT(amed)
        CALL PUSHREAL8(asml)
        asml = SQRT(asml)/ssml
        IF (asml .GT. amed) THEN
          ymin = amed
          ymax = asml
          CALL PUSHCONTROL1B(0)
        ELSE
          ymin = asml
          ymax = amed
          CALL PUSHCONTROL1B(1)
        END IF
        scl = one
        sumsq = ymax**2*(one+(ymin/ymax)**2)
        CALL PUSHCONTROL2B(1)
      ELSE
        scl = one/ssml
        sumsq = asml
        CALL PUSHCONTROL2B(2)
      END IF
    ELSE
!
!     Otherwise all values are mid-range
!
      scl = one
      sumsq = amed
      CALL PUSHCONTROL2B(3)
    END IF
    IF (sumsq .EQ. 0.0) THEN
      sumsqb = 0.0_8
    ELSE
      sumsqb = scl*dnrm2b/(2.0*SQRT(sumsq))
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        abigb = sumsqb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          amedb = sbig**2*abigb
        ELSE
          amedb = 0.0_8
        END IF
        asmlb = 0.0_8
        GOTO 100
      ELSE
        temp = ymin/ymax
        tempb = 2*temp*ymax*sumsqb
        ymaxb = 2*ymax*(one+temp**2)*sumsqb - temp*tempb
        yminb = tempb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          asmlb = ymaxb
          amedb = yminb
        ELSE
          amedb = ymaxb
          asmlb = yminb
        END IF
        CALL POPREAL8(asml)
        IF (asml .EQ. 0.0) THEN
          asmlb = 0.0_8
        ELSE
          asmlb = asmlb/(2.0*SQRT(asml)*ssml)
        END IF
        CALL POPREAL8(amed)
        IF (amed .EQ. 0.0) THEN
          amedb = 0.0_8
        ELSE
          amedb = amedb/(2.0*SQRT(amed))
        END IF
      END IF
    ELSE IF (branch .EQ. 2) THEN
      asmlb = sumsqb
      amedb = 0.0_8
    ELSE
      amedb = sumsqb
      asmlb = 0.0_8
    END IF
    abigb = 0.0_8
 100 xb(1:1+(n-1)*abs(incx)) = 0.0_8
    DO i=n,1,-1
      CALL POPINTEGER4(ix)
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          axb = sbig**2*2*ax*abigb
        ELSE
          axb = ssml**2*2*ax*asmlb
        END IF
      ELSE IF (branch .EQ. 2) THEN
        axb = 0.0_8
      ELSE
        axb = 2*ax*amedb
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(ax)
        xb(ix) = xb(ix) + axb
      ELSE
        CALL POPREAL8(ax)
        xb(ix) = xb(ix) - axb
      END IF
    END DO
  END IF
END SUBROUTINE DNRM2_B

