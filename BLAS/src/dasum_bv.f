C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of dasum in reverse (adjoint) mode (with options multiDirectional):
C   gradient     of useful results: dasum
C   with respect to varying inputs: dx
C   RW status of diff variables: dx:out dasum:in-killed
C> \brief \b DASUM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,N
C       ..
C       .. Array Arguments ..
C       DOUBLE PRECISION DX(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C>    DASUM takes the sum of the absolute values.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>         number of elements in input vector(s)
C> \endverbatim
C>
C> \param[in] DX
C> \verbatim
C>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>         storage spacing between elements of DX
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup asum
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>     jack dongarra, linpack, 3/11/78.
C>     modified 3/93 to return if incx .le. 0.
C>     modified 12/3/93, array(1) declarations changed to array(*)
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE DASUM_BV(n, dx, dxb, incx, dasumb, nbdirs)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE1OFdx should be the size of dimension 1 of array dx
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C  -- Reference BLAS level1 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, n
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION dx(*)
      DOUBLE PRECISION dxb(nbdirsmax, *)
C     ..
C
C  =====================================================================
C
C     .. Local Scalars ..
      DOUBLE PRECISION dtemp
      DOUBLE PRECISION dtempb(nbdirsmax)
      INTEGER i, m, mp1, nincx
      INTEGER ISIZE1OFDx
      INTEGER get_ISIZE1OFDx
      EXTERNAL get_ISIZE1OFDx
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS, MOD
      DOUBLE PRECISION dabs0
      DOUBLE PRECISION dabs0b(nbdirsmax)
      DOUBLE PRECISION dabs1
      DOUBLE PRECISION dabs1b(nbdirsmax)
      DOUBLE PRECISION dabs2
      DOUBLE PRECISION dabs2b(nbdirsmax)
      DOUBLE PRECISION dabs3
      DOUBLE PRECISION dabs3b(nbdirsmax)
      DOUBLE PRECISION dabs4
      DOUBLE PRECISION dabs4b(nbdirsmax)
      DOUBLE PRECISION dabs5
      DOUBLE PRECISION dabs5b(nbdirsmax)
      DOUBLE PRECISION dabs6
      DOUBLE PRECISION dabs6b(nbdirsmax)
      DOUBLE PRECISION dabs7
      DOUBLE PRECISION dabs7b(nbdirsmax)
      INTEGER nd
      INTEGER*4 branch
      INTEGER ii1
      DOUBLE PRECISION dasumb(nbdirsmax)
      DOUBLE PRECISION dasum
      INTEGER nbdirs
C     ..
C     Check 0 < nbdirs <= nbdirsmax (required by DIFFSIZES.inc)
      CALL check_ISIZE1OFDx_initialized()
      ISIZE1OFDx = get_ISIZE1OFDx()
      IF (nbdirs.LE.0 .OR. nbdirs.GT.nbdirsmax) THEN
        WRITE(*,'(A,I0,A,I0,A)') 'Error: nbdirs=', nbdirs,
     +  ' must be in 1..nbdirsmax=', nbdirsmax, '. Stopping.'
        STOP 1
      END IF
C
      IF (n .LE. 0 .OR. incx .LE. 0) THEN
        DO ii1=1,ISIZE1OFdx
          DO nd=1,nbdirsmax
            dxb(nd, ii1) = 0.D0
          ENDDO
        ENDDO
      ELSE
        IF (incx .EQ. 1) THEN
C        code for increment equal to 1
C
C
C        clean-up loop
C
          m = MOD(n, 6)
          IF (m .NE. 0) THEN
            DO i=1,m
              IF (dx(i) .GE. 0.) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            ENDDO
            IF (n .LT. 6) THEN
              DO nd=1,nbdirs
                dtempb(nd) = dasumb(nd)
              ENDDO
              DO ii1=1,ISIZE1OFdx
                DO nd=1,nbdirsmax
                  dxb(nd, ii1) = 0.D0
                ENDDO
              ENDDO
              GOTO 100
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          mp1 = m + 1
          DO i=mp1,n,6
            IF (dx(i) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+1) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+2) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+3) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+4) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+5) .GE. 0.) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
          CALL PUSHCONTROL1B(0)
        ELSE
C
C        code for increment not equal to 1
C
          nincx = n*incx
          DO i=1,nincx,incx
            IF (dx(i) .GE. 0.) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
          CALL PUSHCONTROL1B(1)
        END IF
        DO nd=1,nbdirs
          dtempb(nd) = dasumb(nd)
        ENDDO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO ii1=1,ISIZE1OFdx
            DO nd=1,nbdirsmax
              dxb(nd, ii1) = 0.D0
            ENDDO
          ENDDO
          DO i=n-MOD(n-mp1, 6),mp1,-6
            DO nd=1,nbdirs
              dabs1b(nd) = dtempb(nd)
              dabs3b(nd) = dtempb(nd)
              dabs4b(nd) = dtempb(nd)
              dabs5b(nd) = dtempb(nd)
              dabs6b(nd) = dtempb(nd)
              dabs7b(nd) = dtempb(nd)
            ENDDO
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                dxb(nd, i+5) = dxb(nd, i+5) + dabs7b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                dxb(nd, i+5) = dxb(nd, i+5) - dabs7b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                dxb(nd, i+4) = dxb(nd, i+4) - dabs6b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                dxb(nd, i+4) = dxb(nd, i+4) + dabs6b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                dxb(nd, i+3) = dxb(nd, i+3) - dabs5b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                dxb(nd, i+3) = dxb(nd, i+3) + dabs5b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                dxb(nd, i+2) = dxb(nd, i+2) - dabs4b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                dxb(nd, i+2) = dxb(nd, i+2) + dabs4b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                dxb(nd, i+1) = dxb(nd, i+1) - dabs3b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                dxb(nd, i+1) = dxb(nd, i+1) + dabs3b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                dxb(nd, i) = dxb(nd, i) - dabs1b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                dxb(nd, i) = dxb(nd, i) + dabs1b(nd)
              ENDDO
            END IF
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) GOTO 110
        ELSE
          DO ii1=1,ISIZE1OFdx
            DO nd=1,nbdirsmax
              dxb(nd, ii1) = 0.D0
            ENDDO
          ENDDO
          DO i=nincx-MOD(nincx-1, incx),1,-incx
            DO nd=1,nbdirs
              dabs2b(nd) = dtempb(nd)
            ENDDO
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                dxb(nd, i) = dxb(nd, i) + dabs2b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                dxb(nd, i) = dxb(nd, i) - dabs2b(nd)
              ENDDO
            END IF
          ENDDO
          GOTO 110
        END IF
 100    DO i=m,1,-1
          DO nd=1,nbdirs
            dabs0b(nd) = dtempb(nd)
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            DO nd=1,nbdirs
              dxb(nd, i) = dxb(nd, i) + dabs0b(nd)
            ENDDO
          ELSE
            DO nd=1,nbdirs
              dxb(nd, i) = dxb(nd, i) - dabs0b(nd)
            ENDDO
          END IF
        ENDDO
      END IF
 110  CONTINUE
      END

