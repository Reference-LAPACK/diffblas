C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of dasum in forward (tangent) mode (with options multiDirectional):
C   variations   of useful results: dasum
C   with respect to varying inputs: dx
C   RW status of diff variables: dx:in dasum:out
C> \brief \b DASUM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,N
C       ..
C       .. Array Arguments ..
C       DOUBLE PRECISION DX(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C>    DASUM takes the sum of the absolute values.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>         number of elements in input vector(s)
C> \endverbatim
C>
C> \param[in] DX
C> \verbatim
C>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>         storage spacing between elements of DX
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup asum
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>     jack dongarra, linpack, 3/11/78.
C>     modified 3/93 to return if incx .le. 0.
C>     modified 12/3/93, array(1) declarations changed to array(*)
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE DASUM_DV(n, dx, dxd, incx, dasum, dasumd, nbdirs)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C  -- Reference BLAS level1 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, n
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION dx(*)
      DOUBLE PRECISION dxd(nbdirsmax, *)
C     ..
C
C  =====================================================================
C
C     .. Local Scalars ..
      DOUBLE PRECISION dtemp
      DOUBLE PRECISION dtempd(nbdirsmax)
      INTEGER i, m, mp1, nincx
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS, MOD
      DOUBLE PRECISION dabs0
      DOUBLE PRECISION dabs0d(nbdirsmax)
      DOUBLE PRECISION dabs1
      DOUBLE PRECISION dabs1d(nbdirsmax)
      DOUBLE PRECISION dabs2
      DOUBLE PRECISION dabs2d(nbdirsmax)
      DOUBLE PRECISION dabs3
      DOUBLE PRECISION dabs3d(nbdirsmax)
      DOUBLE PRECISION dabs4
      DOUBLE PRECISION dabs4d(nbdirsmax)
      DOUBLE PRECISION dabs5
      DOUBLE PRECISION dabs5d(nbdirsmax)
      DOUBLE PRECISION dabs6
      DOUBLE PRECISION dabs6d(nbdirsmax)
      DOUBLE PRECISION dabs7
      DOUBLE PRECISION dabs7d(nbdirsmax)
      INTEGER nd
      DOUBLE PRECISION dasumd(nbdirsmax)
      DOUBLE PRECISION dasum
      INTEGER nbdirs
C     ..
C     Check 0 < nbdirs <= nbdirsmax (required by DIFFSIZES.inc)
      IF (nbdirs.LE.0 .OR. nbdirs.GT.nbdirsmax) THEN
        WRITE(*,'(A,I0,A,I0,A)') 'Error: nbdirs=', nbdirs,
     +  ' must be in 1..nbdirsmax=', nbdirsmax, '. Stopping.'
        STOP 1
      END IF
C
      dasum = 0.0d0
      dtemp = 0.0d0
      IF (n .LE. 0 .OR. incx .LE. 0) THEN
        DO nd=1,nbdirsmax
          dasumd(nd) = 0.D0
        ENDDO
        RETURN
      ELSE
        IF (incx .EQ. 1) THEN
C        code for increment equal to 1
C
C
C        clean-up loop
C
          m = MOD(n, 6)
          IF (m .NE. 0) THEN
            DO nd=1,nbdirsmax
              dtempd(nd) = 0.D0
            ENDDO
            DO i=1,m
              IF (dx(i) .GE. 0.) THEN
                DO nd=1,nbdirs
                  dabs0d(nd) = dxd(nd, i)
                ENDDO
                dabs0 = dx(i)
              ELSE
                DO nd=1,nbdirs
                  dabs0d(nd) = -dxd(nd, i)
                ENDDO
                dabs0 = -dx(i)
              END IF
              DO nd=1,nbdirs
                dtempd(nd) = dtempd(nd) + dabs0d(nd)
              ENDDO
              dtemp = dtemp + dabs0
            ENDDO
            IF (n .LT. 6) THEN
              DO nd=1,nbdirs
                dasumd(nd) = dtempd(nd)
              ENDDO
              dasum = dtemp
              RETURN
            END IF
          ELSE
            DO nd=1,nbdirsmax
              dtempd(nd) = 0.D0
            ENDDO
          END IF
          mp1 = m + 1
          DO i=mp1,n,6
            IF (dx(i) .GE. 0.) THEN
              DO nd=1,nbdirs
                dabs1d(nd) = dxd(nd, i)
              ENDDO
              dabs1 = dx(i)
            ELSE
              DO nd=1,nbdirs
                dabs1d(nd) = -dxd(nd, i)
              ENDDO
              dabs1 = -dx(i)
            END IF
            IF (dx(i+1) .GE. 0.) THEN
              DO nd=1,nbdirs
                dabs3d(nd) = dxd(nd, i+1)
              ENDDO
              dabs3 = dx(i+1)
            ELSE
              DO nd=1,nbdirs
                dabs3d(nd) = -dxd(nd, i+1)
              ENDDO
              dabs3 = -dx(i+1)
            END IF
            IF (dx(i+2) .GE. 0.) THEN
              DO nd=1,nbdirs
                dabs4d(nd) = dxd(nd, i+2)
              ENDDO
              dabs4 = dx(i+2)
            ELSE
              DO nd=1,nbdirs
                dabs4d(nd) = -dxd(nd, i+2)
              ENDDO
              dabs4 = -dx(i+2)
            END IF
            IF (dx(i+3) .GE. 0.) THEN
              DO nd=1,nbdirs
                dabs5d(nd) = dxd(nd, i+3)
              ENDDO
              dabs5 = dx(i+3)
            ELSE
              DO nd=1,nbdirs
                dabs5d(nd) = -dxd(nd, i+3)
              ENDDO
              dabs5 = -dx(i+3)
            END IF
            IF (dx(i+4) .GE. 0.) THEN
              DO nd=1,nbdirs
                dabs6d(nd) = dxd(nd, i+4)
              ENDDO
              dabs6 = dx(i+4)
            ELSE
              DO nd=1,nbdirs
                dabs6d(nd) = -dxd(nd, i+4)
              ENDDO
              dabs6 = -dx(i+4)
            END IF
            IF (dx(i+5) .GE. 0.) THEN
              DO nd=1,nbdirs
                dabs7d(nd) = dxd(nd, i+5)
              ENDDO
              dabs7 = dx(i+5)
            ELSE
              DO nd=1,nbdirs
                dabs7d(nd) = -dxd(nd, i+5)
              ENDDO
              dabs7 = -dx(i+5)
            END IF
            DO nd=1,nbdirs
              dtempd(nd) = dtempd(nd) + dabs1d(nd) + dabs3d(nd) + dabs4d
     +          (nd) + dabs5d(nd) + dabs6d(nd) + dabs7d(nd)
            ENDDO
            dtemp = dtemp + dabs1 + dabs3 + dabs4 + dabs5 + dabs6 + 
     +        dabs7
          ENDDO
        ELSE
C
C        code for increment not equal to 1
C
          nincx = n*incx
          DO nd=1,nbdirsmax
            dtempd(nd) = 0.D0
          ENDDO
          DO i=1,nincx,incx
            IF (dx(i) .GE. 0.) THEN
              DO nd=1,nbdirs
                dabs2d(nd) = dxd(nd, i)
              ENDDO
              dabs2 = dx(i)
            ELSE
              DO nd=1,nbdirs
                dabs2d(nd) = -dxd(nd, i)
              ENDDO
              dabs2 = -dx(i)
            END IF
            DO nd=1,nbdirs
              dtempd(nd) = dtempd(nd) + dabs2d(nd)
            ENDDO
            dtemp = dtemp + dabs2
          ENDDO
        END IF
        DO nd=1,nbdirs
          dasumd(nd) = dtempd(nd)
        ENDDO
        dasum = dtemp
        RETURN
C
C     End of DASUM
C
      END IF
      END

