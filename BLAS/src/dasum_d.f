C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of dasum in forward (tangent) mode:
C   variations   of useful results: dasum
C   with respect to varying inputs: dx
C   RW status of diff variables: dx:in dasum:out
C> \brief \b DASUM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,N
C       ..
C       .. Array Arguments ..
C       DOUBLE PRECISION DX(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C>    DASUM takes the sum of the absolute values.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>         number of elements in input vector(s)
C> \endverbatim
C>
C> \param[in] DX
C> \verbatim
C>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>         storage spacing between elements of DX
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup asum
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>     jack dongarra, linpack, 3/11/78.
C>     modified 3/93 to return if incx .le. 0.
C>     modified 12/3/93, array(1) declarations changed to array(*)
C> \endverbatim
C>
C  =====================================================================
      DOUBLE PRECISION FUNCTION DASUM_D(n, dx, dxd, incx, dasum)
      IMPLICIT NONE
C
C  -- Reference BLAS level1 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, n
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION dx(*)
      DOUBLE PRECISION dxd(*)
C     ..
C
C  =====================================================================
C
C     .. Local Scalars ..
      DOUBLE PRECISION dtemp
      DOUBLE PRECISION dtempd
      INTEGER i, m, mp1, nincx
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS, MOD
      DOUBLE PRECISION dabs0
      DOUBLE PRECISION dabs0d
      DOUBLE PRECISION dabs1
      DOUBLE PRECISION dabs1d
      DOUBLE PRECISION dabs2
      DOUBLE PRECISION dabs2d
      DOUBLE PRECISION dabs3
      DOUBLE PRECISION dabs3d
      DOUBLE PRECISION dabs4
      DOUBLE PRECISION dabs4d
      DOUBLE PRECISION dabs5
      DOUBLE PRECISION dabs5d
      DOUBLE PRECISION dabs6
      DOUBLE PRECISION dabs6d
      DOUBLE PRECISION dabs7
      DOUBLE PRECISION dabs7d
      DOUBLE PRECISION dasum
C     ..
      dasum = 0.0d0
      dtemp = 0.0d0
      IF (n .LE. 0 .OR. incx .LE. 0) THEN
        dasum_d = 0.D0
        RETURN
      ELSE
        IF (incx .EQ. 1) THEN
C        code for increment equal to 1
C
C
C        clean-up loop
C
          m = MOD(n, 6)
          IF (m .NE. 0) THEN
            dtempd = 0.D0
            DO i=1,m
              IF (dx(i) .GE. 0.) THEN
                dabs0d = dxd(i)
                dabs0 = dx(i)
              ELSE
                dabs0d = -dxd(i)
                dabs0 = -dx(i)
              END IF
              dtempd = dtempd + dabs0d
              dtemp = dtemp + dabs0
            ENDDO
            IF (n .LT. 6) THEN
              dasum_d = dtempd
              dasum = dtemp
              RETURN
            END IF
          ELSE
            dtempd = 0.D0
          END IF
          mp1 = m + 1
          DO i=mp1,n,6
            IF (dx(i) .GE. 0.) THEN
              dabs1d = dxd(i)
              dabs1 = dx(i)
            ELSE
              dabs1d = -dxd(i)
              dabs1 = -dx(i)
            END IF
            IF (dx(i+1) .GE. 0.) THEN
              dabs3d = dxd(i+1)
              dabs3 = dx(i+1)
            ELSE
              dabs3d = -dxd(i+1)
              dabs3 = -dx(i+1)
            END IF
            IF (dx(i+2) .GE. 0.) THEN
              dabs4d = dxd(i+2)
              dabs4 = dx(i+2)
            ELSE
              dabs4d = -dxd(i+2)
              dabs4 = -dx(i+2)
            END IF
            IF (dx(i+3) .GE. 0.) THEN
              dabs5d = dxd(i+3)
              dabs5 = dx(i+3)
            ELSE
              dabs5d = -dxd(i+3)
              dabs5 = -dx(i+3)
            END IF
            IF (dx(i+4) .GE. 0.) THEN
              dabs6d = dxd(i+4)
              dabs6 = dx(i+4)
            ELSE
              dabs6d = -dxd(i+4)
              dabs6 = -dx(i+4)
            END IF
            IF (dx(i+5) .GE. 0.) THEN
              dabs7d = dxd(i+5)
              dabs7 = dx(i+5)
            ELSE
              dabs7d = -dxd(i+5)
              dabs7 = -dx(i+5)
            END IF
            dtempd = dtempd + dabs1d + dabs3d + dabs4d + dabs5d + dabs6d
     +        + dabs7d
            dtemp = dtemp + dabs1 + dabs3 + dabs4 + dabs5 + dabs6 + 
     +        dabs7
          ENDDO
        ELSE
C
C        code for increment not equal to 1
C
          nincx = n*incx
          dtempd = 0.D0
          DO i=1,nincx,incx
            IF (dx(i) .GE. 0.) THEN
              dabs2d = dxd(i)
              dabs2 = dx(i)
            ELSE
              dabs2d = -dxd(i)
              dabs2 = -dx(i)
            END IF
            dtempd = dtempd + dabs2d
            dtemp = dtemp + dabs2
          ENDDO
        END IF
        dasum_d = dtempd
        dasum = dtemp
        RETURN
C
C     End of DASUM
C
      END IF
      END

