C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of ztbmv in reverse (adjoint) mode (with options multiDirectional):
C   gradient     of useful results: x
C   with respect to varying inputs: x a
C   RW status of diff variables: x:in-out a:out
C> \brief \b ZTBMV
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       SUBROUTINE ZTBMV(UPLO,TRANS,DIAG,N,K,A,LDA,X,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,K,LDA,N
C       CHARACTER DIAG,TRANS,UPLO
C       ..
C       .. Array Arguments ..
C       COMPLEX*16 A(LDA,*),X(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C> ZTBMV  performs one of the matrix-vector operations
C>
C>    x := A*x,   or   x := A**T*x,   or   x := A**H*x,
C>
C> where x is an n element vector and  A is an n by n unit, or non-unit,
C> upper or lower triangular band matrix, with ( k + 1 ) diagonals.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] UPLO
C> \verbatim
C>          UPLO is CHARACTER*1
C>           On entry, UPLO specifies whether the matrix is an upper or
C>           lower triangular matrix as follows:
C>
C>              UPLO = 'U' or 'u'   A is an upper triangular matrix.
C>
C>              UPLO = 'L' or 'l'   A is a lower triangular matrix.
C> \endverbatim
C>
C> \param[in] TRANS
C> \verbatim
C>          TRANS is CHARACTER*1
C>           On entry, TRANS specifies the operation to be performed as
C>           follows:
C>
C>              TRANS = 'N' or 'n'   x := A*x.
C>
C>              TRANS = 'T' or 't'   x := A**T*x.
C>
C>              TRANS = 'C' or 'c'   x := A**H*x.
C> \endverbatim
C>
C> \param[in] DIAG
C> \verbatim
C>          DIAG is CHARACTER*1
C>           On entry, DIAG specifies whether or not A is unit
C>           triangular as follows:
C>
C>              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
C>
C>              DIAG = 'N' or 'n'   A is not assumed to be unit
C>                                  triangular.
C> \endverbatim
C>
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>           On entry, N specifies the order of the matrix A.
C>           N must be at least zero.
C> \endverbatim
C>
C> \param[in] K
C> \verbatim
C>          K is INTEGER
C>           On entry with UPLO = 'U' or 'u', K specifies the number of
C>           super-diagonals of the matrix A.
C>           On entry with UPLO = 'L' or 'l', K specifies the number of
C>           sub-diagonals of the matrix A.
C>           K must satisfy  0 .le. K.
C> \endverbatim
C>
C> \param[in] A
C> \verbatim
C>          A is COMPLEX*16 array, dimension ( LDA, N ).
C>           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
C>           by n part of the array A must contain the upper triangular
C>           band part of the matrix of coefficients, supplied column by
C>           column, with the leading diagonal of the matrix in row
C>           ( k + 1 ) of the array, the first super-diagonal starting at
C>           position 2 in row k, and so on. The top left k by k triangle
C>           of the array A is not referenced.
C>           The following program segment will transfer an upper
C>           triangular band matrix from conventional full matrix storage
C>           to band storage:
C>
C>                 DO 20, J = 1, N
C>                    M = K + 1 - J
C>                    DO 10, I = MAX( 1, J - K ), J
C>                       A( M + I, J ) = matrix( I, J )
C>              10    CONTINUE
C>              20 CONTINUE
C>
C>           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
C>           by n part of the array A must contain the lower triangular
C>           band part of the matrix of coefficients, supplied column by
C>           column, with the leading diagonal of the matrix in row 1 of
C>           the array, the first sub-diagonal starting at position 1 in
C>           row 2, and so on. The bottom right k by k triangle of the
C>           array A is not referenced.
C>           The following program segment will transfer a lower
C>           triangular band matrix from conventional full matrix storage
C>           to band storage:
C>
C>                 DO 20, J = 1, N
C>                    M = 1 - J
C>                    DO 10, I = J, MIN( N, J + K )
C>                       A( M + I, J ) = matrix( I, J )
C>              10    CONTINUE
C>              20 CONTINUE
C>
C>           Note that when DIAG = 'U' or 'u' the elements of the array A
C>           corresponding to the diagonal elements of the matrix are not
C>           referenced, but are assumed to be unity.
C> \endverbatim
C>
C> \param[in] LDA
C> \verbatim
C>          LDA is INTEGER
C>           On entry, LDA specifies the first dimension of A as declared
C>           in the calling (sub) program. LDA must be at least
C>           ( k + 1 ).
C> \endverbatim
C>
C> \param[in,out] X
C> \verbatim
C>          X is COMPLEX*16 array, dimension at least
C>           ( 1 + ( n - 1 )*abs( INCX ) ).
C>           Before entry, the incremented array X must contain the n
C>           element vector x. On exit, X is overwritten with the
C>           transformed vector x.
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>           On entry, INCX specifies the increment for the elements of
C>           X. INCX must not be zero.
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup tbmv
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>  Level 2 Blas routine.
C>  The vector and matrix arguments are not referenced when N = 0, or M = 0
C>
C>  -- Written on 22-October-1986.
C>     Jack Dongarra, Argonne National Lab.
C>     Jeremy Du Croz, Nag Central Office.
C>     Sven Hammarling, Nag Central Office.
C>     Richard Hanson, Sandia National Labs.
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE ZTBMV_BV(uplo, trans, diag, n, k, a, ab, lda, x, xb, 
     +                    incx, nbdirs)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE2OFa should be the size of dimension 2 of array a
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C  -- Reference BLAS level2 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, k, lda, n
      CHARACTER diag, trans, uplo
C     ..
C     .. Array Arguments ..
      COMPLEX*16 a(lda, *), x(*)
      COMPLEX*16 ab(nbdirsmax, lda, *), xb(nbdirsmax, *)
C     ..
C
C  =====================================================================
C
C     .. Parameters ..
      COMPLEX*16 zero
      PARAMETER (zero=(0.0d+0,0.0d+0))
C     ..
C     .. Local Scalars ..
      COMPLEX*16 temp
      COMPLEX*16 tempb(nbdirsmax)
      INTEGER i, info, ix, j, jx, kplus1, kx, l
      LOGICAL noconj, nounit
      EXTERNAL LSAME
      INTEGER ISIZE2OFA
C     ..
C     .. External Functions ..
      INTEGER get_ISIZE2OFA
      EXTERNAL get_ISIZE2OFA
      LOGICAL LSAME
C     ..
C     .. External Subroutines ..
      EXTERNAL XERBLA, check_ISIZE2OFA_initialized
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DCONJG, MAX, MIN
      INTEGER max1
      INTEGER max2
      INTEGER min1
      INTEGER min2
      INTEGER max3
      INTEGER max4
      INTEGER max5
      INTEGER max6
      INTEGER min3
      INTEGER min4
      INTEGER min5
      INTEGER min6
      INTEGER nd
      INTEGER ad_from
      INTEGER ad_to
      INTEGER*4 branch
      INTEGER ad_from0
      INTEGER ad_to0
      INTEGER ad_from1
      INTEGER ad_to1
      INTEGER ad_from2
      INTEGER ad_to2
      INTEGER ad_from3
      INTEGER ad_to3
      INTEGER ad_from4
      INTEGER ad_to4
      INTEGER ad_from5
      INTEGER ad_to5
      INTEGER ad_from6
      INTEGER ad_to6
      INTEGER ad_from7
      INTEGER ad_to7
      INTEGER ad_from8
      INTEGER ad_to8
      INTEGER ad_from9
      INTEGER ad_to9
      INTEGER ad_from10
      INTEGER ad_to10
      INTEGER ii2
      INTEGER ii1
      INTEGER nbdirs
C     ..
C
C     Test the input parameters.
C
C     Check 0 < nbdirs <= nbdirsmax (required by DIFFSIZES.inc)
      CALL check_ISIZE2OFA_initialized()
      ISIZE2OFA = get_ISIZE2OFA()
      IF (nbdirs.LE.0 .OR. nbdirs.GT.nbdirsmax) THEN
        WRITE(*,'(A,I0,A,I0,A)') 'Error: nbdirs=', nbdirs,
     +  ' must be in 1..nbdirsmax=', nbdirsmax, '. Stopping.'
        STOP 1
      END IF
C
      info = 0
      IF (.NOT.LSAME(uplo, 'U') .AND. (.NOT.LSAME(uplo, 'L'))) THEN
        CALL PUSHCONTROL3B(0)
        info = 1
      ELSE IF (.NOT.LSAME(trans, 'N') .AND. (.NOT.LSAME(trans, 'T')) 
     +    .AND. (.NOT.LSAME(trans, 'C'))) THEN
        CALL PUSHCONTROL3B(1)
        info = 2
      ELSE IF (.NOT.LSAME(diag, 'U') .AND. (.NOT.LSAME(diag, 'N'))) THEN
        CALL PUSHCONTROL3B(2)
        info = 3
      ELSE IF (n .LT. 0) THEN
        CALL PUSHCONTROL3B(3)
        info = 4
      ELSE IF (k .LT. 0) THEN
        CALL PUSHCONTROL3B(4)
        info = 5
      ELSE IF (lda .LT. k + 1) THEN
        CALL PUSHCONTROL3B(5)
        info = 7
      ELSE IF (incx .EQ. 0) THEN
        CALL PUSHCONTROL3B(6)
        info = 9
      ELSE
        CALL PUSHCONTROL3B(6)
      END IF
      IF (info .EQ. 0) THEN
C
C     Quick return if possible.
C
        IF (n .EQ. 0) THEN
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              DO nd=1,nbdirsmax
                ab(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
          noconj = LSAME(trans, 'T')
          nounit = LSAME(diag, 'N')
C
C     Set up the start point in X if the increment is not unity. This
C     will be  ( N - 1 )*INCX   too small for descending loops.
C
          IF (incx .LE. 0) THEN
            CALL PUSHCONTROL1B(0)
            kx = 1 - (n-1)*incx
          ELSE IF (incx .NE. 1) THEN
            CALL PUSHCONTROL1B(1)
            kx = 1
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
C
C     Start the operations. In this version the elements of A are
C     accessed sequentially with one pass through A.
C
          IF (LSAME(trans, 'N')) THEN
C
C         Form  x := A*x.
C
            IF (LSAME(uplo, 'U')) THEN
              kplus1 = k + 1
              IF (incx .EQ. 1) THEN
                DO j=1,n
                  IF (x(j) .NE. zero) THEN
                    CALL PUSHCOMPLEX16(temp)
                    temp = x(j)
                    l = kplus1 - j
                    IF (1 .LT. j - k) THEN
                      max1 = j - k
                    ELSE
                      max1 = 1
                    END IF
                    ad_from = max1
                    DO i=ad_from,j-1
                      CALL PUSHCOMPLEX16(x(i))
                      x(i) = x(i) + temp*a(l+i, j)
                    ENDDO
                    CALL PUSHINTEGER4(i - 1)
                    CALL PUSHINTEGER4(ad_from)
                    IF (nounit) THEN
                      CALL PUSHCOMPLEX16(x(j))
                      x(j) = x(j)*a(kplus1, j)
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE
                    CALL PUSHCONTROL2B(2)
                  END IF
                ENDDO
                DO ii1=1,ISIZE2OFa
                  DO ii2=1,lda
                    DO nd=1,nbdirsmax
                      ab(nd, ii2, ii1) = (0.0,0.0)
                    ENDDO
                  ENDDO
                ENDDO
                DO 100 j=n,1,-1
                  CALL POPCONTROL2B(branch)
                  IF (branch .EQ. 0) THEN
                    CALL POPCOMPLEX16(x(j))
                    DO nd=1,nbdirs
                      ab(nd, kplus1, j) = ab(nd, kplus1, j) + CONJG(x(j)
     +                  )*xb(nd, j)
                      xb(nd, j) = CONJG(a(kplus1, j))*xb(nd, j)
                    ENDDO
                  ELSE IF (branch .NE. 1) THEN
                    GOTO 100
                  END IF
                  l = kplus1 - j
                  DO nd=1,nbdirsmax
                    tempb(nd) = (0.0,0.0)
                  ENDDO
                  CALL POPINTEGER4(ad_from)
                  CALL POPINTEGER4(ad_to)
                  DO i=ad_to,ad_from,-1
                    CALL POPCOMPLEX16(x(i))
                    DO nd=1,nbdirs
                      tempb(nd) = tempb(nd) + CONJG(a(l+i, j))*xb(nd, i)
                      ab(nd, l+i, j) = ab(nd, l+i, j) + CONJG(temp)*xb(
     +                  nd, i)
                    ENDDO
                  ENDDO
                  CALL POPCOMPLEX16(temp)
                  DO nd=1,nbdirs
                    xb(nd, j) = xb(nd, j) + tempb(nd)
                  ENDDO
 100            CONTINUE
              ELSE
                jx = kx
                DO j=1,n
                  IF (x(jx) .NE. zero) THEN
                    CALL PUSHCOMPLEX16(temp)
                    temp = x(jx)
                    ix = kx
                    l = kplus1 - j
                    IF (1 .LT. j - k) THEN
                      max2 = j - k
                    ELSE
                      max2 = 1
                    END IF
                    ad_from0 = max2
                    DO i=ad_from0,j-1
                      CALL PUSHCOMPLEX16(x(ix))
                      x(ix) = x(ix) + temp*a(l+i, j)
                      CALL PUSHINTEGER4(ix)
                      ix = ix + incx
                    ENDDO
                    CALL PUSHINTEGER4(i - 1)
                    CALL PUSHINTEGER4(ad_from0)
                    IF (nounit) THEN
                      CALL PUSHCOMPLEX16(x(jx))
                      x(jx) = x(jx)*a(kplus1, j)
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE
                    CALL PUSHCONTROL2B(2)
                  END IF
                  CALL PUSHINTEGER4(jx)
                  jx = jx + incx
                  IF (j .GT. k) THEN
                    CALL PUSHCONTROL1B(0)
                    kx = kx + incx
                  ELSE
                    CALL PUSHCONTROL1B(1)
                  END IF
                ENDDO
                DO ii1=1,ISIZE2OFa
                  DO ii2=1,lda
                    DO nd=1,nbdirsmax
                      ab(nd, ii2, ii1) = (0.0,0.0)
                    ENDDO
                  ENDDO
                ENDDO
                DO 110 j=n,1,-1
                  CALL POPCONTROL1B(branch)
                  CALL POPINTEGER4(jx)
                  CALL POPCONTROL2B(branch)
                  IF (branch .EQ. 0) THEN
                    CALL POPCOMPLEX16(x(jx))
                    DO nd=1,nbdirs
                      ab(nd, kplus1, j) = ab(nd, kplus1, j) + CONJG(x(jx
     +                  ))*xb(nd, jx)
                      xb(nd, jx) = CONJG(a(kplus1, j))*xb(nd, jx)
                    ENDDO
                  ELSE IF (branch .NE. 1) THEN
                    GOTO 110
                  END IF
                  l = kplus1 - j
                  DO nd=1,nbdirsmax
                    tempb(nd) = (0.0,0.0)
                  ENDDO
                  CALL POPINTEGER4(ad_from0)
                  CALL POPINTEGER4(ad_to0)
                  DO i=ad_to0,ad_from0,-1
                    CALL POPINTEGER4(ix)
                    CALL POPCOMPLEX16(x(ix))
                    DO nd=1,nbdirs
                      tempb(nd) = tempb(nd) + CONJG(a(l+i, j))*xb(nd, ix
     +                  )
                      ab(nd, l+i, j) = ab(nd, l+i, j) + CONJG(temp)*xb(
     +                  nd, ix)
                    ENDDO
                  ENDDO
                  CALL POPCOMPLEX16(temp)
                  DO nd=1,nbdirs
                    xb(nd, jx) = xb(nd, jx) + tempb(nd)
                  ENDDO
 110            CONTINUE
              END IF
            ELSE IF (incx .EQ. 1) THEN
              DO j=n,1,-1
                IF (x(j) .NE. zero) THEN
                  CALL PUSHCOMPLEX16(temp)
                  temp = x(j)
                  l = 1 - j
                  IF (n .GT. j + k) THEN
                    min1 = j + k
                  ELSE
                    min1 = n
                  END IF
                  ad_from1 = min1
                  DO i=ad_from1,j+1,-1
                    CALL PUSHCOMPLEX16(x(i))
                    x(i) = x(i) + temp*a(l+i, j)
                  ENDDO
                  CALL PUSHINTEGER4(i + 1)
                  CALL PUSHINTEGER4(ad_from1)
                  IF (nounit) THEN
                    CALL PUSHCOMPLEX16(x(j))
                    x(j) = x(j)*a(1, j)
                    CALL PUSHCONTROL2B(0)
                  ELSE
                    CALL PUSHCONTROL2B(1)
                  END IF
                ELSE
                  CALL PUSHCONTROL2B(2)
                END IF
              ENDDO
              DO ii1=1,ISIZE2OFa
                DO ii2=1,lda
                  DO nd=1,nbdirsmax
                    ab(nd, ii2, ii1) = (0.0,0.0)
                  ENDDO
                ENDDO
              ENDDO
              DO 120 j=1,n,1
                CALL POPCONTROL2B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPCOMPLEX16(x(j))
                  DO nd=1,nbdirs
                    ab(nd, 1, j) = ab(nd, 1, j) + CONJG(x(j))*xb(nd, j)
                    xb(nd, j) = CONJG(a(1, j))*xb(nd, j)
                  ENDDO
                ELSE IF (branch .NE. 1) THEN
                  GOTO 120
                END IF
                l = 1 - j
                DO nd=1,nbdirsmax
                  tempb(nd) = (0.0,0.0)
                ENDDO
                CALL POPINTEGER4(ad_from1)
                CALL POPINTEGER4(ad_to1)
                DO i=ad_to1,ad_from1,1
                  CALL POPCOMPLEX16(x(i))
                  DO nd=1,nbdirs
                    tempb(nd) = tempb(nd) + CONJG(a(l+i, j))*xb(nd, i)
                    ab(nd, l+i, j) = ab(nd, l+i, j) + CONJG(temp)*xb(nd
     +                , i)
                  ENDDO
                ENDDO
                CALL POPCOMPLEX16(temp)
                DO nd=1,nbdirs
                  xb(nd, j) = xb(nd, j) + tempb(nd)
                ENDDO
 120          CONTINUE
            ELSE
              kx = kx + (n-1)*incx
              jx = kx
              DO j=n,1,-1
                IF (x(jx) .NE. zero) THEN
                  CALL PUSHCOMPLEX16(temp)
                  temp = x(jx)
                  ix = kx
                  l = 1 - j
                  IF (n .GT. j + k) THEN
                    min2 = j + k
                  ELSE
                    min2 = n
                  END IF
                  ad_from2 = min2
                  DO i=ad_from2,j+1,-1
                    CALL PUSHCOMPLEX16(x(ix))
                    x(ix) = x(ix) + temp*a(l+i, j)
                    CALL PUSHINTEGER4(ix)
                    ix = ix - incx
                  ENDDO
                  CALL PUSHINTEGER4(i + 1)
                  CALL PUSHINTEGER4(ad_from2)
                  IF (nounit) THEN
                    CALL PUSHCOMPLEX16(x(jx))
                    x(jx) = x(jx)*a(1, j)
                    CALL PUSHCONTROL2B(0)
                  ELSE
                    CALL PUSHCONTROL2B(1)
                  END IF
                ELSE
                  CALL PUSHCONTROL2B(2)
                END IF
                CALL PUSHINTEGER4(jx)
                jx = jx - incx
                IF (n - j .GE. k) THEN
                  CALL PUSHCONTROL1B(0)
                  kx = kx - incx
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
              DO ii1=1,ISIZE2OFa
                DO ii2=1,lda
                  DO nd=1,nbdirsmax
                    ab(nd, ii2, ii1) = (0.0,0.0)
                  ENDDO
                ENDDO
              ENDDO
              DO 130 j=1,n,1
                CALL POPCONTROL1B(branch)
                CALL POPINTEGER4(jx)
                CALL POPCONTROL2B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPCOMPLEX16(x(jx))
                  DO nd=1,nbdirs
                    ab(nd, 1, j) = ab(nd, 1, j) + CONJG(x(jx))*xb(nd, jx
     +                )
                    xb(nd, jx) = CONJG(a(1, j))*xb(nd, jx)
                  ENDDO
                ELSE IF (branch .NE. 1) THEN
                  GOTO 130
                END IF
                l = 1 - j
                DO nd=1,nbdirsmax
                  tempb(nd) = (0.0,0.0)
                ENDDO
                CALL POPINTEGER4(ad_from2)
                CALL POPINTEGER4(ad_to2)
                DO i=ad_to2,ad_from2,1
                  CALL POPINTEGER4(ix)
                  CALL POPCOMPLEX16(x(ix))
                  DO nd=1,nbdirs
                    tempb(nd) = tempb(nd) + CONJG(a(l+i, j))*xb(nd, ix)
                    ab(nd, l+i, j) = ab(nd, l+i, j) + CONJG(temp)*xb(nd
     +                , ix)
                  ENDDO
                ENDDO
                CALL POPCOMPLEX16(temp)
                DO nd=1,nbdirs
                  xb(nd, jx) = xb(nd, jx) + tempb(nd)
                ENDDO
 130          CONTINUE
            END IF
          ELSE IF (LSAME(uplo, 'U')) THEN
C
C        Form  x := A**T*x  or  x := A**H*x.
C
            kplus1 = k + 1
            IF (incx .EQ. 1) THEN
              DO j=n,1,-1
                temp = x(j)
                l = kplus1 - j
                IF (noconj) THEN
                  IF (nounit) THEN
                    CALL PUSHCOMPLEX16(temp)
                    temp = temp*a(kplus1, j)
                    CALL PUSHCONTROL1B(1)
                  ELSE
                    CALL PUSHCONTROL1B(0)
                  END IF
                  IF (1 .LT. j - k) THEN
                    max3 = j - k
                  ELSE
                    max3 = 1
                  END IF
                  ad_from3 = j - 1
                  DO i=ad_from3,max3,-1
                    temp = temp + a(l+i, j)*x(i)
                  ENDDO
                  CALL PUSHINTEGER4(i + 1)
                  CALL PUSHINTEGER4(ad_from3)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  IF (nounit) THEN
                    CALL PUSHCOMPLEX16(temp)
                    temp = temp*DCONJG(a(kplus1, j))
                    CALL PUSHCONTROL1B(1)
                  ELSE
                    CALL PUSHCONTROL1B(0)
                  END IF
                  IF (1 .LT. j - k) THEN
                    max4 = j - k
                  ELSE
                    max4 = 1
                  END IF
                  ad_from4 = j - 1
                  DO i=ad_from4,max4,-1
                    temp = temp + DCONJG(a(l+i, j))*x(i)
                  ENDDO
                  CALL PUSHINTEGER4(i + 1)
                  CALL PUSHINTEGER4(ad_from4)
                  CALL PUSHCONTROL1B(1)
                END IF
                CALL PUSHCOMPLEX16(x(j))
                x(j) = temp
              ENDDO
              DO ii1=1,ISIZE2OFa
                DO ii2=1,lda
                  DO nd=1,nbdirsmax
                    ab(nd, ii2, ii1) = (0.0,0.0)
                  ENDDO
                ENDDO
              ENDDO
              DO j=1,n,1
                CALL POPCOMPLEX16(x(j))
                l = kplus1 - j
                DO nd=1,nbdirs
                  tempb(nd) = xb(nd, j)
                  xb(nd, j) = (0.0,0.0)
                ENDDO
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPINTEGER4(ad_from3)
                  CALL POPINTEGER4(ad_to3)
                  DO i=ad_to3,ad_from3,1
                    DO nd=1,nbdirs
                      ab(nd, l+i, j) = ab(nd, l+i, j) + CONJG(x(i))*
     +                  tempb(nd)
                      xb(nd, i) = xb(nd, i) + CONJG(a(l+i, j))*tempb(nd)
                    ENDDO
                  ENDDO
                  CALL POPCONTROL1B(branch)
                  IF (branch .NE. 0) THEN
                    CALL POPCOMPLEX16(temp)
                    DO nd=1,nbdirs
                      ab(nd, kplus1, j) = ab(nd, kplus1, j) + CONJG(temp
     +                  )*tempb(nd)
                      tempb(nd) = CONJG(a(kplus1, j))*tempb(nd)
                    ENDDO
                  END IF
                ELSE
                  CALL POPINTEGER4(ad_from4)
                  CALL POPINTEGER4(ad_to4)
                  DO i=ad_to4,ad_from4,1
                    DO nd=1,nbdirs
                      ab(nd, l+i, j) = ab(nd, l+i, j) + DCONJG(CONJG(x(i
     +                  ))*tempb(nd))
                      xb(nd, i) = xb(nd, i) + CONJG(DCONJG(a(l+i, j)))*
     +                  tempb(nd)
                    ENDDO
                  ENDDO
                  CALL POPCONTROL1B(branch)
                  IF (branch .NE. 0) THEN
                    CALL POPCOMPLEX16(temp)
                    DO nd=1,nbdirs
                      ab(nd, kplus1, j) = ab(nd, kplus1, j) + DCONJG(
     +                  CONJG(temp)*tempb(nd))
                      tempb(nd) = CONJG(DCONJG(a(kplus1, j)))*tempb(nd)
                    ENDDO
                  END IF
                END IF
                DO nd=1,nbdirs
                  xb(nd, j) = xb(nd, j) + tempb(nd)
                ENDDO
              ENDDO
            ELSE
              kx = kx + (n-1)*incx
              jx = kx
              DO j=n,1,-1
                temp = x(jx)
                kx = kx - incx
                ix = kx
                l = kplus1 - j
                IF (noconj) THEN
                  IF (nounit) THEN
                    CALL PUSHCOMPLEX16(temp)
                    temp = temp*a(kplus1, j)
                    CALL PUSHCONTROL1B(1)
                  ELSE
                    CALL PUSHCONTROL1B(0)
                  END IF
                  IF (1 .LT. j - k) THEN
                    max5 = j - k
                  ELSE
                    max5 = 1
                  END IF
                  ad_from5 = j - 1
                  DO i=ad_from5,max5,-1
                    temp = temp + a(l+i, j)*x(ix)
                    CALL PUSHINTEGER4(ix)
                    ix = ix - incx
                  ENDDO
                  CALL PUSHINTEGER4(i + 1)
                  CALL PUSHINTEGER4(ad_from5)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  IF (nounit) THEN
                    CALL PUSHCOMPLEX16(temp)
                    temp = temp*DCONJG(a(kplus1, j))
                    CALL PUSHCONTROL1B(1)
                  ELSE
                    CALL PUSHCONTROL1B(0)
                  END IF
                  IF (1 .LT. j - k) THEN
                    max6 = j - k
                  ELSE
                    max6 = 1
                  END IF
                  ad_from6 = j - 1
                  DO i=ad_from6,max6,-1
                    temp = temp + DCONJG(a(l+i, j))*x(ix)
                    CALL PUSHINTEGER4(ix)
                    ix = ix - incx
                  ENDDO
                  CALL PUSHINTEGER4(i + 1)
                  CALL PUSHINTEGER4(ad_from6)
                  CALL PUSHCONTROL1B(1)
                END IF
                CALL PUSHCOMPLEX16(x(jx))
                x(jx) = temp
                CALL PUSHINTEGER4(jx)
                jx = jx - incx
              ENDDO
              DO ii1=1,ISIZE2OFa
                DO ii2=1,lda
                  DO nd=1,nbdirsmax
                    ab(nd, ii2, ii1) = (0.0,0.0)
                  ENDDO
                ENDDO
              ENDDO
              DO j=1,n,1
                CALL POPINTEGER4(jx)
                CALL POPCOMPLEX16(x(jx))
                l = kplus1 - j
                DO nd=1,nbdirs
                  tempb(nd) = xb(nd, jx)
                  xb(nd, jx) = (0.0,0.0)
                ENDDO
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPINTEGER4(ad_from5)
                  CALL POPINTEGER4(ad_to5)
                  DO i=ad_to5,ad_from5,1
                    CALL POPINTEGER4(ix)
                    DO nd=1,nbdirs
                      ab(nd, l+i, j) = ab(nd, l+i, j) + CONJG(x(ix))*
     +                  tempb(nd)
                      xb(nd, ix) = xb(nd, ix) + CONJG(a(l+i, j))*tempb(
     +                  nd)
                    ENDDO
                  ENDDO
                  CALL POPCONTROL1B(branch)
                  IF (branch .NE. 0) THEN
                    CALL POPCOMPLEX16(temp)
                    DO nd=1,nbdirs
                      ab(nd, kplus1, j) = ab(nd, kplus1, j) + CONJG(temp
     +                  )*tempb(nd)
                      tempb(nd) = CONJG(a(kplus1, j))*tempb(nd)
                    ENDDO
                  END IF
                ELSE
                  CALL POPINTEGER4(ad_from6)
                  CALL POPINTEGER4(ad_to6)
                  DO i=ad_to6,ad_from6,1
                    CALL POPINTEGER4(ix)
                    DO nd=1,nbdirs
                      ab(nd, l+i, j) = ab(nd, l+i, j) + DCONJG(CONJG(x(
     +                  ix))*tempb(nd))
                      xb(nd, ix) = xb(nd, ix) + CONJG(DCONJG(a(l+i, j)))
     +                  *tempb(nd)
                    ENDDO
                  ENDDO
                  CALL POPCONTROL1B(branch)
                  IF (branch .NE. 0) THEN
                    CALL POPCOMPLEX16(temp)
                    DO nd=1,nbdirs
                      ab(nd, kplus1, j) = ab(nd, kplus1, j) + DCONJG(
     +                  CONJG(temp)*tempb(nd))
                      tempb(nd) = CONJG(DCONJG(a(kplus1, j)))*tempb(nd)
                    ENDDO
                  END IF
                END IF
                DO nd=1,nbdirs
                  xb(nd, jx) = xb(nd, jx) + tempb(nd)
                ENDDO
              ENDDO
            END IF
          ELSE IF (incx .EQ. 1) THEN
            DO j=1,n
              temp = x(j)
              l = 1 - j
              IF (noconj) THEN
                IF (nounit) THEN
                  CALL PUSHCOMPLEX16(temp)
                  temp = temp*a(1, j)
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
                IF (n .GT. j + k) THEN
                  min3 = j + k
                ELSE
                  min3 = n
                END IF
                ad_from7 = j + 1
                DO i=ad_from7,min3
                  temp = temp + a(l+i, j)*x(i)
                ENDDO
                CALL PUSHINTEGER4(i - 1)
                CALL PUSHINTEGER4(ad_from7)
                CALL PUSHCONTROL1B(0)
              ELSE
                IF (nounit) THEN
                  CALL PUSHCOMPLEX16(temp)
                  temp = temp*DCONJG(a(1, j))
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
                IF (n .GT. j + k) THEN
                  min4 = j + k
                ELSE
                  min4 = n
                END IF
                ad_from8 = j + 1
                DO i=ad_from8,min4
                  temp = temp + DCONJG(a(l+i, j))*x(i)
                ENDDO
                CALL PUSHINTEGER4(i - 1)
                CALL PUSHINTEGER4(ad_from8)
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHCOMPLEX16(x(j))
              x(j) = temp
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              CALL POPCOMPLEX16(x(j))
              l = 1 - j
              DO nd=1,nbdirs
                tempb(nd) = xb(nd, j)
                xb(nd, j) = (0.0,0.0)
              ENDDO
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPINTEGER4(ad_from7)
                CALL POPINTEGER4(ad_to7)
                DO i=ad_to7,ad_from7,-1
                  DO nd=1,nbdirs
                    ab(nd, l+i, j) = ab(nd, l+i, j) + CONJG(x(i))*tempb(
     +                nd)
                    xb(nd, i) = xb(nd, i) + CONJG(a(l+i, j))*tempb(nd)
                  ENDDO
                ENDDO
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  CALL POPCOMPLEX16(temp)
                  DO nd=1,nbdirs
                    ab(nd, 1, j) = ab(nd, 1, j) + CONJG(temp)*tempb(nd)
                    tempb(nd) = CONJG(a(1, j))*tempb(nd)
                  ENDDO
                END IF
              ELSE
                CALL POPINTEGER4(ad_from8)
                CALL POPINTEGER4(ad_to8)
                DO i=ad_to8,ad_from8,-1
                  DO nd=1,nbdirs
                    ab(nd, l+i, j) = ab(nd, l+i, j) + DCONJG(CONJG(x(i))
     +                *tempb(nd))
                    xb(nd, i) = xb(nd, i) + CONJG(DCONJG(a(l+i, j)))*
     +                tempb(nd)
                  ENDDO
                ENDDO
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  CALL POPCOMPLEX16(temp)
                  DO nd=1,nbdirs
                    ab(nd, 1, j) = ab(nd, 1, j) + DCONJG(CONJG(temp)*
     +                tempb(nd))
                    tempb(nd) = CONJG(DCONJG(a(1, j)))*tempb(nd)
                  ENDDO
                END IF
              END IF
              DO nd=1,nbdirs
                xb(nd, j) = xb(nd, j) + tempb(nd)
              ENDDO
            ENDDO
          ELSE
            jx = kx
            DO j=1,n
              temp = x(jx)
              kx = kx + incx
              ix = kx
              l = 1 - j
              IF (noconj) THEN
                IF (nounit) THEN
                  CALL PUSHCOMPLEX16(temp)
                  temp = temp*a(1, j)
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
                IF (n .GT. j + k) THEN
                  min5 = j + k
                ELSE
                  min5 = n
                END IF
                ad_from9 = j + 1
                DO i=ad_from9,min5
                  temp = temp + a(l+i, j)*x(ix)
                  CALL PUSHINTEGER4(ix)
                  ix = ix + incx
                ENDDO
                CALL PUSHINTEGER4(i - 1)
                CALL PUSHINTEGER4(ad_from9)
                CALL PUSHCONTROL1B(0)
              ELSE
                IF (nounit) THEN
                  CALL PUSHCOMPLEX16(temp)
                  temp = temp*DCONJG(a(1, j))
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
                IF (n .GT. j + k) THEN
                  min6 = j + k
                ELSE
                  min6 = n
                END IF
                ad_from10 = j + 1
                DO i=ad_from10,min6
                  temp = temp + DCONJG(a(l+i, j))*x(ix)
                  CALL PUSHINTEGER4(ix)
                  ix = ix + incx
                ENDDO
                CALL PUSHINTEGER4(i - 1)
                CALL PUSHINTEGER4(ad_from10)
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHCOMPLEX16(x(jx))
              x(jx) = temp
              CALL PUSHINTEGER4(jx)
              jx = jx + incx
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              CALL POPINTEGER4(jx)
              CALL POPCOMPLEX16(x(jx))
              l = 1 - j
              DO nd=1,nbdirs
                tempb(nd) = xb(nd, jx)
                xb(nd, jx) = (0.0,0.0)
              ENDDO
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPINTEGER4(ad_from9)
                CALL POPINTEGER4(ad_to9)
                DO i=ad_to9,ad_from9,-1
                  CALL POPINTEGER4(ix)
                  DO nd=1,nbdirs
                    ab(nd, l+i, j) = ab(nd, l+i, j) + CONJG(x(ix))*tempb
     +                (nd)
                    xb(nd, ix) = xb(nd, ix) + CONJG(a(l+i, j))*tempb(nd)
                  ENDDO
                ENDDO
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  CALL POPCOMPLEX16(temp)
                  DO nd=1,nbdirs
                    ab(nd, 1, j) = ab(nd, 1, j) + CONJG(temp)*tempb(nd)
                    tempb(nd) = CONJG(a(1, j))*tempb(nd)
                  ENDDO
                END IF
              ELSE
                CALL POPINTEGER4(ad_from10)
                CALL POPINTEGER4(ad_to10)
                DO i=ad_to10,ad_from10,-1
                  CALL POPINTEGER4(ix)
                  DO nd=1,nbdirs
                    ab(nd, l+i, j) = ab(nd, l+i, j) + DCONJG(CONJG(x(ix)
     +                )*tempb(nd))
                    xb(nd, ix) = xb(nd, ix) + CONJG(DCONJG(a(l+i, j)))*
     +                tempb(nd)
                  ENDDO
                ENDDO
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  CALL POPCOMPLEX16(temp)
                  DO nd=1,nbdirs
                    ab(nd, 1, j) = ab(nd, 1, j) + DCONJG(CONJG(temp)*
     +                tempb(nd))
                    tempb(nd) = CONJG(DCONJG(a(1, j)))*tempb(nd)
                  ENDDO
                END IF
              END IF
              DO nd=1,nbdirs
                xb(nd, jx) = xb(nd, jx) + tempb(nd)
              ENDDO
            ENDDO
          END IF
          CALL POPCONTROL1B(branch)
        END IF
      END IF
      CALL POPCONTROL3B(branch)
      END

