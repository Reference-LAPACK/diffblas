C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of dasum in reverse (adjoint) mode:
C   gradient     of useful results: dasum
C   with respect to varying inputs: dx
C   RW status of diff variables: dx:out dasum:in-killed
C> \brief \b DASUM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       DOUBLE PRECISION FUNCTION DASUM(N,DX,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,N
C       ..
C       .. Array Arguments ..
C       DOUBLE PRECISION DX(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C>    DASUM takes the sum of the absolute values.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>         number of elements in input vector(s)
C> \endverbatim
C>
C> \param[in] DX
C> \verbatim
C>          DX is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>         storage spacing between elements of DX
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup asum
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>     jack dongarra, linpack, 3/11/78.
C>     modified 3/93 to return if incx .le. 0.
C>     modified 12/3/93, array(1) declarations changed to array(*)
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE DASUM_B(n, dx, dxb, incx, dasumb)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE1OFdx should be the size of dimension 1 of array dx
C
C  -- Reference BLAS level1 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, n
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION dx(*)
      DOUBLE PRECISION dxb(*)
C     ..
C
C  =====================================================================
C
C     .. Local Scalars ..
      DOUBLE PRECISION dtemp
      DOUBLE PRECISION dtempb
      INTEGER i, m, mp1, nincx
      INTEGER ISIZE1OFDx
      INTEGER get_ISIZE1OFDx
      EXTERNAL get_ISIZE1OFDx
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS, MOD
      DOUBLE PRECISION dabs0
      DOUBLE PRECISION dabs0b
      DOUBLE PRECISION dabs1
      DOUBLE PRECISION dabs1b
      DOUBLE PRECISION dabs2
      DOUBLE PRECISION dabs2b
      DOUBLE PRECISION dabs3
      DOUBLE PRECISION dabs3b
      DOUBLE PRECISION dabs4
      DOUBLE PRECISION dabs4b
      DOUBLE PRECISION dabs5
      DOUBLE PRECISION dabs5b
      DOUBLE PRECISION dabs6
      DOUBLE PRECISION dabs6b
      DOUBLE PRECISION dabs7
      DOUBLE PRECISION dabs7b
      INTEGER*4 branch
      INTEGER ii1
      DOUBLE PRECISION dasumb
      DOUBLE PRECISION dasum
C     ..
      CALL check_ISIZE1OFDx_initialized()
      ISIZE1OFDx = get_ISIZE1OFDx()
      IF (n .LE. 0 .OR. incx .LE. 0) THEN
        DO ii1=1,ISIZE1OFdx
          dxb(ii1) = 0.D0
        ENDDO
      ELSE
        IF (incx .EQ. 1) THEN
C        code for increment equal to 1
C
C
C        clean-up loop
C
          m = MOD(n, 6)
          IF (m .NE. 0) THEN
            DO i=1,m
              IF (dx(i) .GE. 0.) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            ENDDO
            IF (n .LT. 6) THEN
              dtempb = dasumb
              DO ii1=1,ISIZE1OFdx
                dxb(ii1) = 0.D0
              ENDDO
              GOTO 100
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          mp1 = m + 1
          DO i=mp1,n,6
            IF (dx(i) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+1) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+2) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+3) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+4) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (dx(i+5) .GE. 0.) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
          CALL PUSHCONTROL1B(0)
        ELSE
C
C        code for increment not equal to 1
C
          nincx = n*incx
          DO i=1,nincx,incx
            IF (dx(i) .GE. 0.) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
          CALL PUSHCONTROL1B(1)
        END IF
        dtempb = dasumb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO ii1=1,ISIZE1OFdx
            dxb(ii1) = 0.D0
          ENDDO
          DO i=n-MOD(n-mp1, 6),mp1,-6
            dabs1b = dtempb
            dabs3b = dtempb
            dabs4b = dtempb
            dabs5b = dtempb
            dabs6b = dtempb
            dabs7b = dtempb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dxb(i+5) = dxb(i+5) + dabs7b
            ELSE
              dxb(i+5) = dxb(i+5) - dabs7b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dxb(i+4) = dxb(i+4) - dabs6b
            ELSE
              dxb(i+4) = dxb(i+4) + dabs6b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dxb(i+3) = dxb(i+3) - dabs5b
            ELSE
              dxb(i+3) = dxb(i+3) + dabs5b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dxb(i+2) = dxb(i+2) - dabs4b
            ELSE
              dxb(i+2) = dxb(i+2) + dabs4b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dxb(i+1) = dxb(i+1) - dabs3b
            ELSE
              dxb(i+1) = dxb(i+1) + dabs3b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dxb(i) = dxb(i) - dabs1b
            ELSE
              dxb(i) = dxb(i) + dabs1b
            END IF
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) GOTO 110
        ELSE
          DO ii1=1,ISIZE1OFdx
            dxb(ii1) = 0.D0
          ENDDO
          DO i=nincx-MOD(nincx-1, incx),1,-incx
            dabs2b = dtempb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dxb(i) = dxb(i) + dabs2b
            ELSE
              dxb(i) = dxb(i) - dabs2b
            END IF
          ENDDO
          GOTO 110
        END IF
 100    DO i=m,1,-1
          dabs0b = dtempb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dxb(i) = dxb(i) + dabs0b
          ELSE
            dxb(i) = dxb(i) - dabs0b
          END IF
        ENDDO
      END IF
 110  CONTINUE
      END

