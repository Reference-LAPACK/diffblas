C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of sasum in forward (tangent) mode (with options multiDirectional):
C   variations   of useful results: sasum
C   with respect to varying inputs: sx
C   RW status of diff variables: sx:in sasum:out
C> \brief \b SASUM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       REAL FUNCTION SASUM(N,SX,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,N
C       ..
C       .. Array Arguments ..
C       REAL SX(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C>    SASUM takes the sum of the absolute values.
C>    uses unrolled loops for increment equal to one.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>         number of elements in input vector(s)
C> \endverbatim
C>
C> \param[in] SX
C> \verbatim
C>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>         storage spacing between elements of SX
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup asum
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>     jack dongarra, linpack, 3/11/78.
C>     modified 3/93 to return if incx .le. 0.
C>     modified 12/3/93, array(1) declarations changed to array(*)
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE SASUM_DV(n, sx, sxd, incx, sasum, sasumd, nbdirs)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C  -- Reference BLAS level1 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, n
C     ..
C     .. Array Arguments ..
      REAL sx(*)
      REAL sxd(nbdirsmax, *)
C     ..
C
C  =====================================================================
C
C     .. Local Scalars ..
      REAL stemp
      REAL stempd(nbdirsmax)
      INTEGER i, m, mp1, nincx
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS, MOD
      REAL abs0
      REAL abs0d(nbdirsmax)
      REAL abs1
      REAL abs1d(nbdirsmax)
      REAL abs2
      REAL abs2d(nbdirsmax)
      REAL abs3
      REAL abs3d(nbdirsmax)
      REAL abs4
      REAL abs4d(nbdirsmax)
      REAL abs5
      REAL abs5d(nbdirsmax)
      REAL abs6
      REAL abs6d(nbdirsmax)
      REAL abs7
      REAL abs7d(nbdirsmax)
      INTEGER nd
      REAL sasumd(nbdirsmax)
      REAL sasum
      INTEGER nbdirs
C     ..
C     Check 0 < nbdirs <= nbdirsmax (required by DIFFSIZES.inc)
      IF (nbdirs.LE.0 .OR. nbdirs.GT.nbdirsmax) THEN
        WRITE(*,'(A,I0,A,I0,A)') 'Error: nbdirs=', nbdirs,
     +  ' must be in 1..nbdirsmax=', nbdirsmax, '. Stopping.'
        STOP 1
      END IF
C
      sasum = 0.0e0
      stemp = 0.0e0
      IF (n .LE. 0 .OR. incx .LE. 0) THEN
        DO nd=1,nbdirsmax
          sasumd(nd) = 0.0
        ENDDO
        RETURN
      ELSE
        IF (incx .EQ. 1) THEN
C        code for increment equal to 1
C
C
C        clean-up loop
C
          m = MOD(n, 6)
          IF (m .NE. 0) THEN
            DO nd=1,nbdirsmax
              stempd(nd) = 0.0
            ENDDO
            DO i=1,m
              IF (sx(i) .GE. 0.) THEN
                DO nd=1,nbdirs
                  abs0d(nd) = sxd(nd, i)
                ENDDO
                abs0 = sx(i)
              ELSE
                DO nd=1,nbdirs
                  abs0d(nd) = -sxd(nd, i)
                ENDDO
                abs0 = -sx(i)
              END IF
              DO nd=1,nbdirs
                stempd(nd) = stempd(nd) + abs0d(nd)
              ENDDO
              stemp = stemp + abs0
            ENDDO
            IF (n .LT. 6) THEN
              DO nd=1,nbdirs
                sasumd(nd) = stempd(nd)
              ENDDO
              sasum = stemp
              RETURN
            END IF
          ELSE
            DO nd=1,nbdirsmax
              stempd(nd) = 0.0
            ENDDO
          END IF
          mp1 = m + 1
          DO i=mp1,n,6
            IF (sx(i) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs1d(nd) = sxd(nd, i)
              ENDDO
              abs1 = sx(i)
            ELSE
              DO nd=1,nbdirs
                abs1d(nd) = -sxd(nd, i)
              ENDDO
              abs1 = -sx(i)
            END IF
            IF (sx(i+1) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs3d(nd) = sxd(nd, i+1)
              ENDDO
              abs3 = sx(i+1)
            ELSE
              DO nd=1,nbdirs
                abs3d(nd) = -sxd(nd, i+1)
              ENDDO
              abs3 = -sx(i+1)
            END IF
            IF (sx(i+2) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs4d(nd) = sxd(nd, i+2)
              ENDDO
              abs4 = sx(i+2)
            ELSE
              DO nd=1,nbdirs
                abs4d(nd) = -sxd(nd, i+2)
              ENDDO
              abs4 = -sx(i+2)
            END IF
            IF (sx(i+3) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs5d(nd) = sxd(nd, i+3)
              ENDDO
              abs5 = sx(i+3)
            ELSE
              DO nd=1,nbdirs
                abs5d(nd) = -sxd(nd, i+3)
              ENDDO
              abs5 = -sx(i+3)
            END IF
            IF (sx(i+4) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs6d(nd) = sxd(nd, i+4)
              ENDDO
              abs6 = sx(i+4)
            ELSE
              DO nd=1,nbdirs
                abs6d(nd) = -sxd(nd, i+4)
              ENDDO
              abs6 = -sx(i+4)
            END IF
            IF (sx(i+5) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs7d(nd) = sxd(nd, i+5)
              ENDDO
              abs7 = sx(i+5)
            ELSE
              DO nd=1,nbdirs
                abs7d(nd) = -sxd(nd, i+5)
              ENDDO
              abs7 = -sx(i+5)
            END IF
            DO nd=1,nbdirs
              stempd(nd) = stempd(nd) + abs1d(nd) + abs3d(nd) + abs4d(nd
     +          ) + abs5d(nd) + abs6d(nd) + abs7d(nd)
            ENDDO
            stemp = stemp + abs1 + abs3 + abs4 + abs5 + abs6 + abs7
          ENDDO
        ELSE
C
C        code for increment not equal to 1
C
          nincx = n*incx
          DO nd=1,nbdirsmax
            stempd(nd) = 0.0
          ENDDO
          DO i=1,nincx,incx
            IF (sx(i) .GE. 0.) THEN
              DO nd=1,nbdirs
                abs2d(nd) = sxd(nd, i)
              ENDDO
              abs2 = sx(i)
            ELSE
              DO nd=1,nbdirs
                abs2d(nd) = -sxd(nd, i)
              ENDDO
              abs2 = -sx(i)
            END IF
            DO nd=1,nbdirs
              stempd(nd) = stempd(nd) + abs2d(nd)
            ENDDO
            stemp = stemp + abs2
          ENDDO
        END IF
        DO nd=1,nbdirs
          sasumd(nd) = stempd(nd)
        ENDDO
        sasum = stemp
        RETURN
C
C     End of SASUM
C
      END IF
      END

