C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of sasum in reverse (adjoint) mode:
C   gradient     of useful results: sasum
C   with respect to varying inputs: sx
C   RW status of diff variables: sx:out sasum:in-killed
C> \brief \b SASUM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       REAL FUNCTION SASUM(N,SX,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,N
C       ..
C       .. Array Arguments ..
C       REAL SX(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C>    SASUM takes the sum of the absolute values.
C>    uses unrolled loops for increment equal to one.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>         number of elements in input vector(s)
C> \endverbatim
C>
C> \param[in] SX
C> \verbatim
C>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>         storage spacing between elements of SX
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup asum
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>     jack dongarra, linpack, 3/11/78.
C>     modified 3/93 to return if incx .le. 0.
C>     modified 12/3/93, array(1) declarations changed to array(*)
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE SASUM_B(n, sx, sxb, incx, sasumb)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE1OFsx should be the size of dimension 1 of array sx
C
C  -- Reference BLAS level1 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, n
C     ..
C     .. Array Arguments ..
      REAL sx(*)
      REAL sxb(*)
C     ..
C
C  =====================================================================
C
C     .. Local Scalars ..
      REAL stemp
      REAL stempb
      INTEGER i, m, mp1, nincx
      INTEGER ISIZE1OFSx
      INTEGER get_ISIZE1OFSx
      EXTERNAL get_ISIZE1OFSx
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS, MOD
      REAL abs0
      REAL abs0b
      REAL abs1
      REAL abs1b
      REAL abs2
      REAL abs2b
      REAL abs3
      REAL abs3b
      REAL abs4
      REAL abs4b
      REAL abs5
      REAL abs5b
      REAL abs6
      REAL abs6b
      REAL abs7
      REAL abs7b
      INTEGER*4 branch
      INTEGER ii1
      REAL sasumb
      REAL sasum
C     ..
      CALL check_ISIZE1OFSx_initialized()
      ISIZE1OFSx = get_ISIZE1OFSx()
      IF (n .LE. 0 .OR. incx .LE. 0) THEN
        DO ii1=1,ISIZE1OFsx
          sxb(ii1) = 0.0
        ENDDO
      ELSE
        IF (incx .EQ. 1) THEN
C        code for increment equal to 1
C
C
C        clean-up loop
C
          m = MOD(n, 6)
          IF (m .NE. 0) THEN
            DO i=1,m
              IF (sx(i) .GE. 0.) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            ENDDO
            IF (n .LT. 6) THEN
              stempb = sasumb
              DO ii1=1,ISIZE1OFsx
                sxb(ii1) = 0.0
              ENDDO
              GOTO 100
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          mp1 = m + 1
          DO i=mp1,n,6
            IF (sx(i) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+1) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+2) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+3) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+4) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+5) .GE. 0.) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
          CALL PUSHCONTROL1B(0)
        ELSE
C
C        code for increment not equal to 1
C
          nincx = n*incx
          DO i=1,nincx,incx
            IF (sx(i) .GE. 0.) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
          CALL PUSHCONTROL1B(1)
        END IF
        stempb = sasumb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO ii1=1,ISIZE1OFsx
            sxb(ii1) = 0.0
          ENDDO
          DO i=n-MOD(n-mp1, 6),mp1,-6
            abs1b = stempb
            abs3b = stempb
            abs4b = stempb
            abs5b = stempb
            abs6b = stempb
            abs7b = stempb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              sxb(i+5) = sxb(i+5) + abs7b
            ELSE
              sxb(i+5) = sxb(i+5) - abs7b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              sxb(i+4) = sxb(i+4) - abs6b
            ELSE
              sxb(i+4) = sxb(i+4) + abs6b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              sxb(i+3) = sxb(i+3) - abs5b
            ELSE
              sxb(i+3) = sxb(i+3) + abs5b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              sxb(i+2) = sxb(i+2) - abs4b
            ELSE
              sxb(i+2) = sxb(i+2) + abs4b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              sxb(i+1) = sxb(i+1) - abs3b
            ELSE
              sxb(i+1) = sxb(i+1) + abs3b
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              sxb(i) = sxb(i) - abs1b
            ELSE
              sxb(i) = sxb(i) + abs1b
            END IF
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) GOTO 110
        ELSE
          DO ii1=1,ISIZE1OFsx
            sxb(ii1) = 0.0
          ENDDO
          DO i=nincx-MOD(nincx-1, incx),1,-incx
            abs2b = stempb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              sxb(i) = sxb(i) + abs2b
            ELSE
              sxb(i) = sxb(i) - abs2b
            END IF
          ENDDO
          GOTO 110
        END IF
 100    DO i=m,1,-1
          abs0b = stempb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            sxb(i) = sxb(i) + abs0b
          ELSE
            sxb(i) = sxb(i) - abs0b
          END IF
        ENDDO
      END IF
 110  CONTINUE
      END

