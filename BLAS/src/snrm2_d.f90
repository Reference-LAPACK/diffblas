!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
!
!  Differentiation of snrm2 in forward (tangent) mode:
!   variations   of useful results: snrm2
!   with respect to varying inputs: x
!   RW status of diff variables: snrm2:out x:in
!> \brief \b SNRM2
!
!  =========== DOCUMENTATION ===========
!
! Online html documentation available at
!            http://www.netlib.org/lapack/explore-html/
!
!  Definition:
!  ===========
!
!       REAL FUNCTION SNRM2(N,X,INCX)
!
!       .. Scalar Arguments ..
!       INTEGER INCX,N
!       ..
!       .. Array Arguments ..
!       REAL X(*)
!       ..
!
!
!> \par Purpose:
!  =============
!>
!> \verbatim
!>
!> SNRM2 returns the euclidean norm of a vector via the function
!> name, so that
!>
!>    SNRM2 := sqrt( x'*x ).
!> \endverbatim
!
!  Arguments:
!  ==========
!
!> \param[in] N
!> \verbatim
!>          N is INTEGER
!>         number of elements in input vector(s)
!> \endverbatim
!>
!> \param[in] X
!> \verbatim
!>          X is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
!> \endverbatim
!>
!> \param[in] INCX
!> \verbatim
!>          INCX is INTEGER, storage spacing between elements of X
!>          If INCX > 0, X(1+(i-1)*INCX) = x(i) for 1 <= i <= n
!>          If INCX < 0, X(1-(n-i)*INCX) = x(i) for 1 <= i <= n
!>          If INCX = 0, x isn't a vector so there is no need to call
!>          this subroutine.  If you call it anyway, it will count x(1)
!>          in the vector norm N times.
!> \endverbatim
!
!  Authors:
!  ========
!
!> \author Edward Anderson, Lockheed Martin
!
!> \date August 2016
!
!> \ingroup nrm2
!
!> \par Contributors:
!  ==================
!>
!> Weslley Pereira, University of Colorado Denver, USA
!
!> \par Further Details:
!  =====================
!>
!> \verbatim
!>
!>  Anderson E. (2017)
!>  Algorithm 978: Safe Scaling in the Level 1 BLAS
!>  ACM Trans Math Softw 44:1--28
!>  https://doi.org/10.1145/3061665
!>
!>  Blue, James L. (1978)
!>  A Portable Fortran Program to Find the Euclidean Norm of a Vector
!>  ACM Trans Math Softw 4:15--23
!>  https://doi.org/10.1145/355769.355771
!>
!> \endverbatim
!>
!  =====================================================================
FUNCTION SNRM2_D(n, x, xd, incx, snrm2)
  IMPLICIT NONE
  INTRINSIC KIND
  INTEGER, PARAMETER :: wp=KIND(1.e0)
  REAL(wp) :: snrm2
!
!  -- Reference BLAS level1 routine (version 3.9.1) --
!  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
!     March 2021
!
!  .. Constants ..
  REAL(wp), PARAMETER :: zero=0.0_wp
  REAL(wp), PARAMETER :: one=1.0_wp
  INTRINSIC HUGE
  REAL(wp), PARAMETER :: maxn=HUGE(0.0_wp)
  INTRINSIC RADIX
  INTRINSIC MINEXPONENT
  INTRINSIC REAL
  INTRINSIC CEILING
!  ..
!  .. Blue's scaling constants ..
  REAL(wp), PARAMETER :: tsml=REAL(RADIX(0._wp), wp)**CEILING((&
&   MINEXPONENT(0._wp)-1)*0.5_wp)
  INTRINSIC DIGITS
  INTRINSIC FLOOR
  INTRINSIC MAXEXPONENT
  REAL(wp), PARAMETER :: tbig=REAL(RADIX(0._wp), wp)**FLOOR((MAXEXPONENT&
&   (0._wp)-DIGITS(0._wp)+1)*0.5_wp)
  REAL(wp), PARAMETER :: ssml=REAL(RADIX(0._wp), wp)**(-FLOOR((&
&   MINEXPONENT(0._wp)-DIGITS(0._wp))*0.5_wp))
  REAL(wp), PARAMETER :: sbig=REAL(RADIX(0._wp), wp)**(-CEILING((&
&   MAXEXPONENT(0._wp)+DIGITS(0._wp)-1)*0.5_wp))
!  ..
!  .. Scalar Arguments ..
  INTEGER :: incx, n
!  ..
!  .. Array Arguments ..
  REAL(wp) :: x(*)
  REAL(wp) :: xd(*)
!  ..
!  .. Local Scalars ..
  INTEGER :: i, ix
  LOGICAL :: notbig
  REAL(wp) :: abig, amed, asml, ax, scl, sumsq, ymax, ymin
  REAL(wp) :: abigd, amedd, asmld, axd, sumsqd, ymaxd, ymind
  INTRINSIC ABS
  INTRINSIC SQRT
  REAL(wp) :: result1
  REAL(wp) :: result1d
  REAL(wp) :: temp
  REAL(wp) :: snrm2_d
!
!  Quick return if possible
!
  snrm2 = zero
  IF (n .LE. 0) THEN
    snrm2_d = 0.0_4
    RETURN
  ELSE
!
    scl = one
    sumsq = zero
!
!  Compute the sum of squares in 3 accumulators:
!     abig -- sums of squares scaled down to avoid overflow
!     asml -- sums of squares scaled up to avoid underflow
!     amed -- sums of squares that do not require scaling
!  The thresholds and multipliers are
!     tbig -- values bigger than this are scaled down by sbig
!     tsml -- values smaller than this are scaled up by ssml
!
    notbig = .true.
    asml = zero
    amed = zero
    abig = zero
    ix = 1
    IF (incx .LT. 0) THEN
      ix = 1 - (n-1)*incx
      amedd = 0.0_4
      asmld = 0.0_4
      abigd = 0.0_4
    ELSE
      amedd = 0.0_4
      asmld = 0.0_4
      abigd = 0.0_4
    END IF
    DO i=1,n
      IF (x(ix) .GE. 0.) THEN
        axd = xd(ix)
        ax = x(ix)
      ELSE
        axd = -xd(ix)
        ax = -x(ix)
      END IF
      IF (ax .GT. tbig) THEN
        abigd = abigd + 2*sbig**2*ax*axd
        abig = abig + (ax*sbig)**2
        notbig = .false.
      ELSE IF (ax .LT. tsml) THEN
        IF (notbig) THEN
          asmld = asmld + 2*ssml**2*ax*axd
          asml = asml + (ax*ssml)**2
        END IF
      ELSE
        amedd = amedd + 2*ax*axd
        amed = amed + ax**2
      END IF
      ix = ix + incx
    END DO
!
!  Combine abig and amed or amed and asml if more than one
!  accumulator was used.
!
    IF (abig .GT. zero) THEN
!
!     Combine abig and amed if abig > 0.
!
      IF ((amed .GT. zero .OR. amed .GT. maxn) .OR. amed .NE. amed) THEN
        abigd = abigd + sbig**2*amedd
        abig = abig + amed*sbig*sbig
      END IF
      scl = one/sbig
      sumsqd = abigd
      sumsq = abig
    ELSE IF (asml .GT. zero) THEN
!
!     Combine amed and asml if asml > 0.
!
      IF ((amed .GT. zero .OR. amed .GT. maxn) .OR. amed .NE. amed) THEN
        temp = SQRT(amed)
        IF (amed .EQ. 0.0) THEN
          amedd = 0.0_4
        ELSE
          amedd = amedd/(2.0*temp)
        END IF
        amed = temp
        temp = SQRT(asml)
        IF (asml .EQ. 0.0) THEN
          result1d = 0.0_4
        ELSE
          result1d = asmld/(2.0*temp)
        END IF
        result1 = temp
        asmld = result1d/ssml
        asml = result1/ssml
        IF (asml .GT. amed) THEN
          ymind = amedd
          ymin = amed
          ymaxd = asmld
          ymax = asml
        ELSE
          ymind = asmld
          ymin = asml
          ymaxd = amedd
          ymax = amed
        END IF
        scl = one
        temp = ymin/ymax
        sumsqd = (one+temp**2)*2*ymax*ymaxd + ymax*2*temp*(ymind-temp*&
&         ymaxd)
        sumsq = ymax*ymax*(one+temp*temp)
      ELSE
        scl = one/ssml
        sumsqd = asmld
        sumsq = asml
      END IF
    ELSE
!
!     Otherwise all values are mid-range
!
      scl = one
      sumsqd = amedd
      sumsq = amed
    END IF
    temp = SQRT(sumsq)
    IF (sumsq .EQ. 0.0) THEN
      result1d = 0.0_4
    ELSE
      result1d = sumsqd/(2.0*temp)
    END IF
    result1 = temp
    snrm2_d = scl*result1d
    snrm2 = scl*result1
    RETURN
  END IF
END FUNCTION SNRM2_D

