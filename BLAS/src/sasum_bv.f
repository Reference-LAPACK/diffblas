C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of sasum in reverse (adjoint) mode (with options multiDirectional):
C   gradient     of useful results: sasum
C   with respect to varying inputs: sx
C   RW status of diff variables: sx:out sasum:in-killed
C> \brief \b SASUM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       REAL FUNCTION SASUM(N,SX,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,N
C       ..
C       .. Array Arguments ..
C       REAL SX(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C>    SASUM takes the sum of the absolute values.
C>    uses unrolled loops for increment equal to one.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>         number of elements in input vector(s)
C> \endverbatim
C>
C> \param[in] SX
C> \verbatim
C>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>         storage spacing between elements of SX
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup asum
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>     jack dongarra, linpack, 3/11/78.
C>     modified 3/93 to return if incx .le. 0.
C>     modified 12/3/93, array(1) declarations changed to array(*)
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE SASUM_BV(n, sx, sxb, incx, sasumb, nbdirs)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE1OFsx should be the size of dimension 1 of array sx
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C  -- Reference BLAS level1 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, n
C     ..
C     .. Array Arguments ..
      REAL sx(*)
      REAL sxb(nbdirsmax, *)
C     ..
C
C  =====================================================================
C
C     .. Local Scalars ..
      REAL stemp
      REAL stempb(nbdirsmax)
      INTEGER i, m, mp1, nincx
      INTEGER ISIZE1OFSx
      INTEGER get_ISIZE1OFSx
      EXTERNAL get_ISIZE1OFSx
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS, MOD
      REAL abs0
      REAL abs0b(nbdirsmax)
      REAL abs1
      REAL abs1b(nbdirsmax)
      REAL abs2
      REAL abs2b(nbdirsmax)
      REAL abs3
      REAL abs3b(nbdirsmax)
      REAL abs4
      REAL abs4b(nbdirsmax)
      REAL abs5
      REAL abs5b(nbdirsmax)
      REAL abs6
      REAL abs6b(nbdirsmax)
      REAL abs7
      REAL abs7b(nbdirsmax)
      INTEGER nd
      INTEGER*4 branch
      INTEGER ii1
      REAL sasumb(nbdirsmax)
      REAL sasum
      INTEGER nbdirs
C     ..
C     Check 0 < nbdirs <= nbdirsmax (required by DIFFSIZES.inc)
      CALL check_ISIZE1OFSx_initialized()
      ISIZE1OFSx = get_ISIZE1OFSx()
      IF (nbdirs.LE.0 .OR. nbdirs.GT.nbdirsmax) THEN
        WRITE(*,'(A,I0,A,I0,A)') 'Error: nbdirs=', nbdirs,
     +  ' must be in 1..nbdirsmax=', nbdirsmax, '. Stopping.'
        STOP 1
      END IF
C
      IF (n .LE. 0 .OR. incx .LE. 0) THEN
        DO ii1=1,ISIZE1OFsx
          DO nd=1,nbdirsmax
            sxb(nd, ii1) = 0.0
          ENDDO
        ENDDO
      ELSE
        IF (incx .EQ. 1) THEN
C        code for increment equal to 1
C
C
C        clean-up loop
C
          m = MOD(n, 6)
          IF (m .NE. 0) THEN
            DO i=1,m
              IF (sx(i) .GE. 0.) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            ENDDO
            IF (n .LT. 6) THEN
              DO nd=1,nbdirs
                stempb(nd) = sasumb(nd)
              ENDDO
              DO ii1=1,ISIZE1OFsx
                DO nd=1,nbdirsmax
                  sxb(nd, ii1) = 0.0
                ENDDO
              ENDDO
              GOTO 100
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          mp1 = m + 1
          DO i=mp1,n,6
            IF (sx(i) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+1) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+2) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+3) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+4) .GE. 0.) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            IF (sx(i+5) .GE. 0.) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
          CALL PUSHCONTROL1B(0)
        ELSE
C
C        code for increment not equal to 1
C
          nincx = n*incx
          DO i=1,nincx,incx
            IF (sx(i) .GE. 0.) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
          CALL PUSHCONTROL1B(1)
        END IF
        DO nd=1,nbdirs
          stempb(nd) = sasumb(nd)
        ENDDO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO ii1=1,ISIZE1OFsx
            DO nd=1,nbdirsmax
              sxb(nd, ii1) = 0.0
            ENDDO
          ENDDO
          DO i=n-MOD(n-mp1, 6),mp1,-6
            DO nd=1,nbdirs
              abs1b(nd) = stempb(nd)
              abs3b(nd) = stempb(nd)
              abs4b(nd) = stempb(nd)
              abs5b(nd) = stempb(nd)
              abs6b(nd) = stempb(nd)
              abs7b(nd) = stempb(nd)
            ENDDO
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                sxb(nd, i+5) = sxb(nd, i+5) + abs7b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                sxb(nd, i+5) = sxb(nd, i+5) - abs7b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                sxb(nd, i+4) = sxb(nd, i+4) - abs6b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                sxb(nd, i+4) = sxb(nd, i+4) + abs6b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                sxb(nd, i+3) = sxb(nd, i+3) - abs5b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                sxb(nd, i+3) = sxb(nd, i+3) + abs5b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                sxb(nd, i+2) = sxb(nd, i+2) - abs4b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                sxb(nd, i+2) = sxb(nd, i+2) + abs4b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                sxb(nd, i+1) = sxb(nd, i+1) - abs3b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                sxb(nd, i+1) = sxb(nd, i+1) + abs3b(nd)
              ENDDO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                sxb(nd, i) = sxb(nd, i) - abs1b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                sxb(nd, i) = sxb(nd, i) + abs1b(nd)
              ENDDO
            END IF
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) GOTO 110
        ELSE
          DO ii1=1,ISIZE1OFsx
            DO nd=1,nbdirsmax
              sxb(nd, ii1) = 0.0
            ENDDO
          ENDDO
          DO i=nincx-MOD(nincx-1, incx),1,-incx
            DO nd=1,nbdirs
              abs2b(nd) = stempb(nd)
            ENDDO
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO nd=1,nbdirs
                sxb(nd, i) = sxb(nd, i) + abs2b(nd)
              ENDDO
            ELSE
              DO nd=1,nbdirs
                sxb(nd, i) = sxb(nd, i) - abs2b(nd)
              ENDDO
            END IF
          ENDDO
          GOTO 110
        END IF
 100    DO i=m,1,-1
          DO nd=1,nbdirs
            abs0b(nd) = stempb(nd)
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            DO nd=1,nbdirs
              sxb(nd, i) = sxb(nd, i) + abs0b(nd)
            ENDDO
          ELSE
            DO nd=1,nbdirs
              sxb(nd, i) = sxb(nd, i) - abs0b(nd)
            ENDDO
          END IF
        ENDDO
      END IF
 110  CONTINUE
      END

