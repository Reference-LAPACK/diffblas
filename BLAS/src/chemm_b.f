C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of chemm in reverse (adjoint) mode:
C   gradient     of useful results: c
C   with respect to varying inputs: alpha beta a b c
C   RW status of diff variables: alpha:out beta:out a:out b:out
C                c:in-out
C> \brief \b CHEMM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       SUBROUTINE CHEMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
C
C       .. Scalar Arguments ..
C       COMPLEX ALPHA,BETA
C       INTEGER LDA,LDB,LDC,M,N
C       CHARACTER SIDE,UPLO
C       ..
C       .. Array Arguments ..
C       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C> CHEMM  performs one of the matrix-matrix operations
C>
C>    C := alpha*A*B + beta*C,
C>
C> or
C>
C>    C := alpha*B*A + beta*C,
C>
C> where alpha and beta are scalars, A is an hermitian matrix and  B and
C> C are m by n matrices.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] SIDE
C> \verbatim
C>          SIDE is CHARACTER*1
C>           On entry,  SIDE  specifies whether  the  hermitian matrix  A
C>           appears on the  left or right  in the  operation as follows:
C>
C>              SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
C>
C>              SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
C> \endverbatim
C>
C> \param[in] UPLO
C> \verbatim
C>          UPLO is CHARACTER*1
C>           On  entry,   UPLO  specifies  whether  the  upper  or  lower
C>           triangular  part  of  the  hermitian  matrix   A  is  to  be
C>           referenced as follows:
C>
C>              UPLO = 'U' or 'u'   Only the upper triangular part of the
C>                                  hermitian matrix is to be referenced.
C>
C>              UPLO = 'L' or 'l'   Only the lower triangular part of the
C>                                  hermitian matrix is to be referenced.
C> \endverbatim
C>
C> \param[in] M
C> \verbatim
C>          M is INTEGER
C>           On entry,  M  specifies the number of rows of the matrix  C.
C>           M  must be at least zero.
C> \endverbatim
C>
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>           On entry, N specifies the number of columns of the matrix C.
C>           N  must be at least zero.
C> \endverbatim
C>
C> \param[in] ALPHA
C> \verbatim
C>          ALPHA is COMPLEX
C>           On entry, ALPHA specifies the scalar alpha.
C> \endverbatim
C>
C> \param[in] A
C> \verbatim
C>          A is COMPLEX array, dimension ( LDA, ka ), where ka is
C>           m  when  SIDE = 'L' or 'l'  and is n  otherwise.
C>           Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
C>           the array  A  must contain the  hermitian matrix,  such that
C>           when  UPLO = 'U' or 'u', the leading m by m upper triangular
C>           part of the array  A  must contain the upper triangular part
C>           of the  hermitian matrix and the  strictly  lower triangular
C>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
C>           the leading  m by m  lower triangular part  of the  array  A
C>           must  contain  the  lower triangular part  of the  hermitian
C>           matrix and the  strictly upper triangular part of  A  is not
C>           referenced.
C>           Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
C>           the array  A  must contain the  hermitian matrix,  such that
C>           when  UPLO = 'U' or 'u', the leading n by n upper triangular
C>           part of the array  A  must contain the upper triangular part
C>           of the  hermitian matrix and the  strictly  lower triangular
C>           part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
C>           the leading  n by n  lower triangular part  of the  array  A
C>           must  contain  the  lower triangular part  of the  hermitian
C>           matrix and the  strictly upper triangular part of  A  is not
C>           referenced.
C>           Note that the imaginary parts  of the diagonal elements need
C>           not be set, they are assumed to be zero.
C> \endverbatim
C>
C> \param[in] LDA
C> \verbatim
C>          LDA is INTEGER
C>           On entry, LDA specifies the first dimension of A as declared
C>           in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
C>           LDA must be at least  max( 1, m ), otherwise  LDA must be at
C>           least max( 1, n ).
C> \endverbatim
C>
C> \param[in] B
C> \verbatim
C>          B is COMPLEX array, dimension ( LDB, N )
C>           Before entry, the leading  m by n part of the array  B  must
C>           contain the matrix B.
C> \endverbatim
C>
C> \param[in] LDB
C> \verbatim
C>          LDB is INTEGER
C>           On entry, LDB specifies the first dimension of B as declared
C>           in  the  calling  (sub)  program.   LDB  must  be  at  least
C>           max( 1, m ).
C> \endverbatim
C>
C> \param[in] BETA
C> \verbatim
C>          BETA is COMPLEX
C>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
C>           supplied as zero then C need not be set on input.
C> \endverbatim
C>
C> \param[in,out] C
C> \verbatim
C>          C is COMPLEX array, dimension ( LDC, N )
C>           Before entry, the leading  m by n  part of the array  C must
C>           contain the matrix  C,  except when  beta  is zero, in which
C>           case C need not be set on entry.
C>           On exit, the array  C  is overwritten by the  m by n updated
C>           matrix.
C> \endverbatim
C>
C> \param[in] LDC
C> \verbatim
C>          LDC is INTEGER
C>           On entry, LDC specifies the first dimension of C as declared
C>           in  the  calling  (sub)  program.   LDC  must  be  at  least
C>           max( 1, m ).
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup hemm
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>  Level 3 Blas routine.
C>
C>  -- Written on 8-February-1989.
C>     Jack Dongarra, Argonne National Laboratory.
C>     Iain Duff, AERE Harwell.
C>     Jeremy Du Croz, Numerical Algorithms Group Ltd.
C>     Sven Hammarling, Numerical Algorithms Group Ltd.
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE CHEMM_B(side, uplo, m, n, alpha, alphab, a, ab, lda, b
     +                   , bb, ldb, beta, betab, c, cb, ldc)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE2OFb should be the size of dimension 2 of array b
C  Hint: ISIZE2OFa should be the size of dimension 2 of array a
C
C  -- Reference BLAS level3 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      COMPLEX alpha, beta
      COMPLEX alphab, betab
      INTEGER lda, ldb, ldc, m, n
      CHARACTER side, uplo
C     ..
C     .. Array Arguments ..
      COMPLEX a(lda, *), b(ldb, *), c(ldc, *)
      COMPLEX ab(lda, *), bb(ldb, *), cb(ldc, *)
      EXTERNAL LSAME
C     ..
C
C  =====================================================================
C
C     .. External Functions ..
      INTEGER get_ISIZE2OFA, get_ISIZE2OFB
      EXTERNAL get_ISIZE2OFA, get_ISIZE2OFB
      LOGICAL LSAME
C     ..
C     .. External Subroutines ..
      EXTERNAL XERBLA, check_ISIZE2OFA_initialized, check_ISIZE2OFB_initialized
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC CONJG, MAX, REAL
C     ..
C     .. Local Scalars ..
      COMPLEX temp1, temp2
      COMPLEX temp1b, temp2b
      INTEGER i, info, j, k, nrowa
      LOGICAL upper
      INTEGER ISIZE2OFA, ISIZE2OFB
C     ..
C     .. Parameters ..
      COMPLEX one
      PARAMETER (one=(1.0e+0,0.0e+0))
      COMPLEX zero
      PARAMETER (zero=(0.0e+0,0.0e+0))
      INTEGER max1
      INTEGER max2
      INTEGER max3
      INTEGER ad_to
      INTEGER*4 branch
      INTEGER ad_from
      INTEGER ad_to0
      INTEGER ad_from0
      INTEGER ii2
      INTEGER ii1
C     ..
C
C     Set NROWA as the number of rows of A.
C
      CALL check_ISIZE2OFA_initialized()
      CALL check_ISIZE2OFB_initialized()
      ISIZE2OFA = get_ISIZE2OFA()
      ISIZE2OFB = get_ISIZE2OFB()
      IF (LSAME(side, 'L')) THEN
        nrowa = m
      ELSE
        nrowa = n
      END IF
      upper = LSAME(uplo, 'U')
C
C     Test the input parameters.
C
      info = 0
      IF (.NOT.LSAME(side, 'L') .AND. (.NOT.LSAME(side, 'R'))) THEN
        CALL PUSHCONTROL3B(0)
        info = 1
      ELSE IF (.NOT.upper .AND. (.NOT.LSAME(uplo, 'L'))) THEN
        CALL PUSHCONTROL3B(1)
        info = 2
      ELSE IF (m .LT. 0) THEN
        CALL PUSHCONTROL3B(2)
        info = 3
      ELSE IF (n .LT. 0) THEN
        CALL PUSHCONTROL3B(3)
        info = 4
      ELSE
        IF (1 .LT. nrowa) THEN
          max1 = nrowa
        ELSE
          max1 = 1
        END IF
        IF (lda .LT. max1) THEN
          CALL PUSHCONTROL3B(4)
          info = 7
        ELSE
          IF (1 .LT. m) THEN
            max2 = m
          ELSE
            max2 = 1
          END IF
          IF (ldb .LT. max2) THEN
            CALL PUSHCONTROL3B(5)
            info = 9
          ELSE
            IF (1 .LT. m) THEN
              max3 = m
            ELSE
              max3 = 1
            END IF
            IF (ldc .LT. max3) THEN
              CALL PUSHCONTROL3B(6)
              info = 12
            ELSE
              CALL PUSHCONTROL3B(6)
            END IF
          END IF
        END IF
      END IF
      IF (info .EQ. 0) THEN
C
C     Quick return if possible.
C
        IF ((m .EQ. 0 .OR. n .EQ. 0) .OR. (alpha .EQ. zero .AND. beta 
     +      .EQ. one)) THEN
          alphab = (0.0,0.0)
          betab = (0.0,0.0)
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              ab(ii2, ii1) = (0.0,0.0)
            ENDDO
          ENDDO
          DO ii1=1,ISIZE2OFb
            DO ii2=1,ldb
              bb(ii2, ii1) = (0.0,0.0)
            ENDDO
          ENDDO
        ELSE IF (alpha .EQ. zero) THEN
C
C     And when  alpha.eq.zero.
C
          IF (beta .EQ. zero) THEN
            DO j=n,1,-1
              DO i=m,1,-1
                cb(i, j) = (0.0,0.0)
              ENDDO
            ENDDO
            betab = (0.0,0.0)
          ELSE
            betab = (0.0,0.0)
            DO j=n,1,-1
              DO i=m,1,-1
                betab = betab + CONJG(c(i, j))*cb(i, j)
                cb(i, j) = CONJG(beta)*cb(i, j)
              ENDDO
            ENDDO
          END IF
          alphab = (0.0,0.0)
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              ab(ii2, ii1) = (0.0,0.0)
            ENDDO
          ENDDO
          DO ii1=1,ISIZE2OFb
            DO ii2=1,ldb
              bb(ii2, ii1) = (0.0,0.0)
            ENDDO
          ENDDO
        ELSE IF (LSAME(side, 'L')) THEN
C
C     Start the operations.
C
C
C        Form  C := alpha*A*B + beta*C.
C
          IF (upper) THEN
            DO j=1,n
              DO i=1,m
                temp1 = alpha*b(i, j)
                CALL PUSHCOMPLEX8(temp2)
                temp2 = zero
                DO k=1,i-1
                  CALL PUSHCOMPLEX8(c(k, j))
                  c(k, j) = c(k, j) + temp1*a(k, i)
                  temp2 = temp2 + b(k, j)*CONJG(a(k, i))
                ENDDO
                CALL PUSHINTEGER4(k - 1)
                IF (beta .EQ. zero) THEN
                  CALL PUSHCOMPLEX8(c(i, j))
                  c(i, j) = temp1*REAL(a(i, i)) + alpha*temp2
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCOMPLEX8(c(i, j))
                  c(i, j) = beta*c(i, j) + temp1*REAL(a(i, i)) + alpha*
     +              temp2
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
            ENDDO
            alphab = (0.0,0.0)
            betab = (0.0,0.0)
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                ab(ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                bb(ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO i=m,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  temp1 = alpha*b(i, j)
                  CALL POPCOMPLEX8(c(i, j))
                  temp1b = REAL(a(i, i))*cb(i, j)
                  ab(i, i) = ab(i, i) + CONJG(temp1)*cb(i, j)
                  alphab = alphab + CONJG(temp2)*cb(i, j)
                  temp2b = CONJG(alpha)*cb(i, j)
                  cb(i, j) = (0.0,0.0)
                ELSE
                  temp1 = alpha*b(i, j)
                  CALL POPCOMPLEX8(c(i, j))
                  betab = betab + CONJG(c(i, j))*cb(i, j)
                  temp1b = REAL(a(i, i))*cb(i, j)
                  ab(i, i) = ab(i, i) + CONJG(temp1)*cb(i, j)
                  alphab = alphab + CONJG(temp2)*cb(i, j)
                  temp2b = CONJG(alpha)*cb(i, j)
                  cb(i, j) = CONJG(beta)*cb(i, j)
                END IF
                CALL POPINTEGER4(ad_to)
                DO k=ad_to,1,-1
                  bb(k, j) = bb(k, j) + CONJG(CONJG(a(k, i)))*temp2b
                  ab(k, i) = ab(k, i) + CONJG(CONJG(b(k, j))*temp2b) + 
     +              CONJG(temp1)*cb(k, j)
                  CALL POPCOMPLEX8(c(k, j))
                  temp1b = temp1b + CONJG(a(k, i))*cb(k, j)
                ENDDO
                CALL POPCOMPLEX8(temp2)
                alphab = alphab + CONJG(b(i, j))*temp1b
                bb(i, j) = bb(i, j) + CONJG(alpha)*temp1b
              ENDDO
            ENDDO
          ELSE
            DO j=1,n
              DO i=m,1,-1
                temp1 = alpha*b(i, j)
                CALL PUSHCOMPLEX8(temp2)
                temp2 = zero
                ad_from = i + 1
                DO k=ad_from,m
                  CALL PUSHCOMPLEX8(c(k, j))
                  c(k, j) = c(k, j) + temp1*a(k, i)
                  temp2 = temp2 + b(k, j)*CONJG(a(k, i))
                ENDDO
                CALL PUSHINTEGER4(ad_from)
                IF (beta .EQ. zero) THEN
                  CALL PUSHCOMPLEX8(c(i, j))
                  c(i, j) = temp1*REAL(a(i, i)) + alpha*temp2
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCOMPLEX8(c(i, j))
                  c(i, j) = beta*c(i, j) + temp1*REAL(a(i, i)) + alpha*
     +              temp2
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
            ENDDO
            alphab = (0.0,0.0)
            betab = (0.0,0.0)
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                ab(ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                bb(ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO i=1,m,1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  temp1 = alpha*b(i, j)
                  CALL POPCOMPLEX8(c(i, j))
                  temp1b = REAL(a(i, i))*cb(i, j)
                  ab(i, i) = ab(i, i) + CONJG(temp1)*cb(i, j)
                  alphab = alphab + CONJG(temp2)*cb(i, j)
                  temp2b = CONJG(alpha)*cb(i, j)
                  cb(i, j) = (0.0,0.0)
                ELSE
                  temp1 = alpha*b(i, j)
                  CALL POPCOMPLEX8(c(i, j))
                  betab = betab + CONJG(c(i, j))*cb(i, j)
                  temp1b = REAL(a(i, i))*cb(i, j)
                  ab(i, i) = ab(i, i) + CONJG(temp1)*cb(i, j)
                  alphab = alphab + CONJG(temp2)*cb(i, j)
                  temp2b = CONJG(alpha)*cb(i, j)
                  cb(i, j) = CONJG(beta)*cb(i, j)
                END IF
                CALL POPINTEGER4(ad_from)
                DO k=m,ad_from,-1
                  bb(k, j) = bb(k, j) + CONJG(CONJG(a(k, i)))*temp2b
                  ab(k, i) = ab(k, i) + CONJG(CONJG(b(k, j))*temp2b) + 
     +              CONJG(temp1)*cb(k, j)
                  CALL POPCOMPLEX8(c(k, j))
                  temp1b = temp1b + CONJG(a(k, i))*cb(k, j)
                ENDDO
                CALL POPCOMPLEX8(temp2)
                alphab = alphab + CONJG(b(i, j))*temp1b
                bb(i, j) = bb(i, j) + CONJG(alpha)*temp1b
              ENDDO
            ENDDO
          END IF
        ELSE
C
C        Form  C := alpha*B*A + beta*C.
C
          DO j=1,n
            CALL PUSHCOMPLEX8(temp1)
            temp1 = alpha*REAL(a(j, j))
            IF (beta .EQ. zero) THEN
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            DO k=1,j-1
              IF (upper) THEN
                CALL PUSHCOMPLEX8(temp1)
                temp1 = alpha*a(k, j)
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCOMPLEX8(temp1)
                temp1 = alpha*CONJG(a(j, k))
                CALL PUSHCONTROL1B(0)
              END IF
            ENDDO
            CALL PUSHINTEGER4(k - 1)
            ad_from0 = j + 1
            DO k=ad_from0,n
              IF (upper) THEN
                CALL PUSHCOMPLEX8(temp1)
                temp1 = alpha*CONJG(a(j, k))
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCOMPLEX8(temp1)
                temp1 = alpha*a(k, j)
                CALL PUSHCONTROL1B(0)
              END IF
            ENDDO
            CALL PUSHINTEGER4(ad_from0)
          ENDDO
          alphab = (0.0,0.0)
          betab = (0.0,0.0)
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              ab(ii2, ii1) = (0.0,0.0)
            ENDDO
          ENDDO
          DO ii1=1,ISIZE2OFb
            DO ii2=1,ldb
              bb(ii2, ii1) = (0.0,0.0)
            ENDDO
          ENDDO
          DO j=n,1,-1
            CALL POPINTEGER4(ad_from0)
            DO k=n,ad_from0,-1
              temp1b = (0.0,0.0)
              DO i=m,1,-1
                temp1b = temp1b + CONJG(b(i, k))*cb(i, j)
                bb(i, k) = bb(i, k) + CONJG(temp1)*cb(i, j)
              ENDDO
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPCOMPLEX8(temp1)
                alphab = alphab + CONJG(a(k, j))*temp1b
                ab(k, j) = ab(k, j) + CONJG(alpha)*temp1b
              ELSE
                CALL POPCOMPLEX8(temp1)
                alphab = alphab + CONJG(CONJG(a(j, k)))*temp1b
                ab(j, k) = ab(j, k) + CONJG(CONJG(alpha)*temp1b)
              END IF
            ENDDO
            CALL POPINTEGER4(ad_to0)
            DO k=ad_to0,1,-1
              temp1b = (0.0,0.0)
              DO i=m,1,-1
                temp1b = temp1b + CONJG(b(i, k))*cb(i, j)
                bb(i, k) = bb(i, k) + CONJG(temp1)*cb(i, j)
              ENDDO
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPCOMPLEX8(temp1)
                alphab = alphab + CONJG(CONJG(a(j, k)))*temp1b
                ab(j, k) = ab(j, k) + CONJG(CONJG(alpha)*temp1b)
              ELSE
                CALL POPCOMPLEX8(temp1)
                alphab = alphab + CONJG(a(k, j))*temp1b
                ab(k, j) = ab(k, j) + CONJG(alpha)*temp1b
              END IF
            ENDDO
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              temp1b = (0.0,0.0)
              DO i=m,1,-1
                betab = betab + CONJG(c(i, j))*cb(i, j)
                temp1b = temp1b + CONJG(b(i, j))*cb(i, j)
                bb(i, j) = bb(i, j) + CONJG(temp1)*cb(i, j)
                cb(i, j) = CONJG(beta)*cb(i, j)
              ENDDO
            ELSE
              temp1b = (0.0,0.0)
              DO i=m,1,-1
                temp1b = temp1b + CONJG(b(i, j))*cb(i, j)
                bb(i, j) = bb(i, j) + CONJG(temp1)*cb(i, j)
                cb(i, j) = (0.0,0.0)
              ENDDO
            END IF
            CALL POPCOMPLEX8(temp1)
            alphab = alphab + REAL(a(j, j))*temp1b
            ab(j, j) = ab(j, j) + CONJG(alpha)*temp1b
          ENDDO
        END IF
      END IF
      CALL POPCONTROL3B(branch)
      END

