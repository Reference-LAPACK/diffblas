!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
!
!  Differentiation of dnrm2 in forward (tangent) mode (with options multiDirectional):
!   variations   of useful results: dnrm2
!   with respect to varying inputs: x
!   RW status of diff variables: x:in dnrm2:out
!> \brief \b DNRM2
!
!  =========== DOCUMENTATION ===========
!
! Online html documentation available at
!            http://www.netlib.org/lapack/explore-html/
!
!  Definition:
!  ===========
!
!       DOUBLE PRECISION FUNCTION DNRM2(N,X,INCX)
!
!       .. Scalar Arguments ..
!       INTEGER INCX,N
!       ..
!       .. Array Arguments ..
!       DOUBLE PRECISION X(*)
!       ..
!
!
!> \par Purpose:
!  =============
!>
!> \verbatim
!>
!> DNRM2 returns the euclidean norm of a vector via the function
!> name, so that
!>
!>    DNRM2 := sqrt( x'*x )
!> \endverbatim
!
!  Arguments:
!  ==========
!
!> \param[in] N
!> \verbatim
!>          N is INTEGER
!>         number of elements in input vector(s)
!> \endverbatim
!>
!> \param[in] X
!> \verbatim
!>          X is DOUBLE PRECISION array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
!> \endverbatim
!>
!> \param[in] INCX
!> \verbatim
!>          INCX is INTEGER, storage spacing between elements of X
!>          If INCX > 0, X(1+(i-1)*INCX) = x(i) for 1 <= i <= n
!>          If INCX < 0, X(1-(n-i)*INCX) = x(i) for 1 <= i <= n
!>          If INCX = 0, x isn't a vector so there is no need to call
!>          this subroutine.  If you call it anyway, it will count x(1)
!>          in the vector norm N times.
!> \endverbatim
!
!  Authors:
!  ========
!
!> \author Edward Anderson, Lockheed Martin
!
!> \date August 2016
!
!> \ingroup nrm2
!
!> \par Contributors:
!  ==================
!>
!> Weslley Pereira, University of Colorado Denver, USA
!
!> \par Further Details:
!  =====================
!>
!> \verbatim
!>
!>  Anderson E. (2017)
!>  Algorithm 978: Safe Scaling in the Level 1 BLAS
!>  ACM Trans Math Softw 44:1--28
!>  https://doi.org/10.1145/3061665
!>
!>  Blue, James L. (1978)
!>  A Portable Fortran Program to Find the Euclidean Norm of a Vector
!>  ACM Trans Math Softw 4:15--23
!>  https://doi.org/10.1145/355769.355771
!>
!> \endverbatim
!>
!  =====================================================================
SUBROUTINE DNRM2_DV(n, x, xd, incx, dnrm2, dnrm2d, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
  INTEGER, PARAMETER :: wp=KIND(1.d0)
  REAL(wp) :: dnrm2
  REAL(wp), DIMENSION(nbdirsmax) :: dnrm2d
!
!  -- Reference BLAS level1 routine (version 3.9.1) --
!  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
!     March 2021
!
!  .. Constants ..
  REAL(wp), PARAMETER :: zero=0.0_wp
  REAL(wp), PARAMETER :: one=1.0_wp
  INTRINSIC HUGE
  REAL(wp), PARAMETER :: maxn=HUGE(0.0_wp)
  INTRINSIC RADIX
  INTRINSIC MINEXPONENT
  INTRINSIC REAL
  INTRINSIC CEILING
!  ..
!  .. Blue's scaling constants ..
  REAL(wp), PARAMETER :: tsml=REAL(RADIX(0._wp), wp)**CEILING((&
&   MINEXPONENT(0._wp)-1)*0.5_wp)
  INTRINSIC DIGITS
  INTRINSIC FLOOR
  INTRINSIC MAXEXPONENT
  REAL(wp), PARAMETER :: tbig=REAL(RADIX(0._wp), wp)**FLOOR((MAXEXPONENT&
&   (0._wp)-DIGITS(0._wp)+1)*0.5_wp)
  REAL(wp), PARAMETER :: ssml=REAL(RADIX(0._wp), wp)**(-FLOOR((&
&   MINEXPONENT(0._wp)-DIGITS(0._wp))*0.5_wp))
  REAL(wp), PARAMETER :: sbig=REAL(RADIX(0._wp), wp)**(-CEILING((&
&   MAXEXPONENT(0._wp)+DIGITS(0._wp)-1)*0.5_wp))
!  ..
!  .. Scalar Arguments ..
  INTEGER :: incx, n
!  ..
!  .. Array Arguments ..
  REAL(wp) :: x(*)
  REAL(wp) :: xd(nbdirsmax, *)
!  ..
!  .. Local Scalars ..
  INTEGER :: i, ix
  LOGICAL :: notbig
  REAL(wp) :: abig, amed, asml, ax, scl, sumsq, ymax, ymin
  REAL(wp), DIMENSION(nbdirsmax) :: abigd, amedd, asmld, axd, sumsqd, &
& ymaxd, ymind
  INTRINSIC ABS
  INTRINSIC SQRT
  REAL(wp) :: result1
  REAL(wp), DIMENSION(nbdirsmax) :: result1d
  INTEGER :: nd
  REAL(wp) :: temp
  INTEGER :: nbdirs
!
!  Quick return if possible
!
  dnrm2 = zero
! Check 0 < nbdirs <= nbdirsmax (required by DIFFSIZES.inc)
  IF (nbdirs <= 0 .OR. nbdirs > nbdirsmax) THEN
    WRITE(*,'(A,I0,A,I0,A)') 'Error: nbdirs=', nbdirs, &
      ' must be in 1..nbdirsmax=', nbdirsmax, '. Stopping.'
    STOP 1
  END IF
!
  IF (n .LE. 0) THEN
    dnrm2d = 0.0_8
    RETURN
  ELSE
!
    scl = one
    sumsq = zero
!
!  Compute the sum of squares in 3 accumulators:
!     abig -- sums of squares scaled down to avoid overflow
!     asml -- sums of squares scaled up to avoid underflow
!     amed -- sums of squares that do not require scaling
!  The thresholds and multipliers are
!     tbig -- values bigger than this are scaled down by sbig
!     tsml -- values smaller than this are scaled up by ssml
!
    notbig = .true.
    asml = zero
    amed = zero
    abig = zero
    ix = 1
    IF (incx .LT. 0) THEN
      ix = 1 - (n-1)*incx
      amedd = 0.0_8
      asmld = 0.0_8
      abigd = 0.0_8
    ELSE
      amedd = 0.0_8
      asmld = 0.0_8
      abigd = 0.0_8
    END IF
    DO i=1,n
      IF (x(ix) .GE. 0.) THEN
        DO nd=1,nbdirs
          axd(nd) = xd(nd, ix)
        END DO
        ax = x(ix)
      ELSE
        DO nd=1,nbdirs
          axd(nd) = -xd(nd, ix)
        END DO
        ax = -x(ix)
      END IF
      IF (ax .GT. tbig) THEN
        DO nd=1,nbdirs
          abigd(nd) = abigd(nd) + 2*sbig**2*ax*axd(nd)
        END DO
        abig = abig + (ax*sbig)**2
        notbig = .false.
      ELSE IF (ax .LT. tsml) THEN
        IF (notbig) THEN
          DO nd=1,nbdirs
            asmld(nd) = asmld(nd) + 2*ssml**2*ax*axd(nd)
          END DO
          asml = asml + (ax*ssml)**2
        END IF
      ELSE
        DO nd=1,nbdirs
          amedd(nd) = amedd(nd) + 2*ax*axd(nd)
        END DO
        amed = amed + ax**2
      END IF
      ix = ix + incx
    END DO
!
!  Combine abig and amed or amed and asml if more than one
!  accumulator was used.
!
    IF (abig .GT. zero) THEN
!
!     Combine abig and amed if abig > 0.
!
      IF ((amed .GT. zero .OR. amed .GT. maxn) .OR. amed .NE. amed) THEN
        DO nd=1,nbdirs
          abigd(nd) = abigd(nd) + sbig**2*amedd(nd)
        END DO
        abig = abig + amed*sbig*sbig
      END IF
      scl = one/sbig
      DO nd=1,nbdirs
        sumsqd(nd) = abigd(nd)
      END DO
      sumsq = abig
    ELSE IF (asml .GT. zero) THEN
!
!     Combine amed and asml if asml > 0.
!
      IF ((amed .GT. zero .OR. amed .GT. maxn) .OR. amed .NE. amed) THEN
        temp = SQRT(amed)
        DO nd=1,nbdirs
          IF (amed .EQ. 0.0) THEN
            amedd(nd) = 0.0_8
          ELSE
            amedd(nd) = amedd(nd)/(2.0*temp)
          END IF
        END DO
        amed = temp
        temp = SQRT(asml)
        DO nd=1,nbdirs
          IF (asml .EQ. 0.0) THEN
            result1d(nd) = 0.0_8
          ELSE
            result1d(nd) = asmld(nd)/(2.0*temp)
          END IF
          asmld(nd) = result1d(nd)/ssml
        END DO
        result1 = temp
        asml = result1/ssml
        IF (asml .GT. amed) THEN
          DO nd=1,nbdirs
            ymind(nd) = amedd(nd)
            ymaxd(nd) = asmld(nd)
          END DO
          ymin = amed
          ymax = asml
        ELSE
          DO nd=1,nbdirs
            ymind(nd) = asmld(nd)
            ymaxd(nd) = amedd(nd)
          END DO
          ymin = asml
          ymax = amed
        END IF
        scl = one
        temp = ymin/ymax
        DO nd=1,nbdirs
          sumsqd(nd) = (one+temp**2)*2*ymax*ymaxd(nd) + ymax*2*temp*(&
&           ymind(nd)-temp*ymaxd(nd))
        END DO
        sumsq = ymax*ymax*(one+temp*temp)
      ELSE
        scl = one/ssml
        DO nd=1,nbdirs
          sumsqd(nd) = asmld(nd)
        END DO
        sumsq = asml
      END IF
    ELSE
!
!     Otherwise all values are mid-range
!
      scl = one
      DO nd=1,nbdirs
        sumsqd(nd) = amedd(nd)
      END DO
      sumsq = amed
    END IF
    temp = SQRT(sumsq)
    DO nd=1,nbdirs
      IF (sumsq .EQ. 0.0) THEN
        result1d(nd) = 0.0_8
      ELSE
        result1d(nd) = sumsqd(nd)/(2.0*temp)
      END IF
      dnrm2d(nd) = scl*result1d(nd)
    END DO
    result1 = temp
    dnrm2 = scl*result1
    RETURN
  END IF
END SUBROUTINE DNRM2_DV

