C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of sasum in forward (tangent) mode:
C   variations   of useful results: sasum
C   with respect to varying inputs: sx
C   RW status of diff variables: sx:in sasum:out
C> \brief \b SASUM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       REAL FUNCTION SASUM(N,SX,INCX)
C
C       .. Scalar Arguments ..
C       INTEGER INCX,N
C       ..
C       .. Array Arguments ..
C       REAL SX(*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C>    SASUM takes the sum of the absolute values.
C>    uses unrolled loops for increment equal to one.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>         number of elements in input vector(s)
C> \endverbatim
C>
C> \param[in] SX
C> \verbatim
C>          SX is REAL array, dimension ( 1 + ( N - 1 )*abs( INCX ) )
C> \endverbatim
C>
C> \param[in] INCX
C> \verbatim
C>          INCX is INTEGER
C>         storage spacing between elements of SX
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup asum
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>     jack dongarra, linpack, 3/11/78.
C>     modified 3/93 to return if incx .le. 0.
C>     modified 12/3/93, array(1) declarations changed to array(*)
C> \endverbatim
C>
C  =====================================================================
      REAL FUNCTION SASUM_D(n, sx, sxd, incx, sasum)
      IMPLICIT NONE
C
C  -- Reference BLAS level1 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      INTEGER incx, n
C     ..
C     .. Array Arguments ..
      REAL sx(*)
      REAL sxd(*)
C     ..
C
C  =====================================================================
C
C     .. Local Scalars ..
      REAL stemp
      REAL stempd
      INTEGER i, m, mp1, nincx
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC ABS, MOD
      REAL abs0
      REAL abs0d
      REAL abs1
      REAL abs1d
      REAL abs2
      REAL abs2d
      REAL abs3
      REAL abs3d
      REAL abs4
      REAL abs4d
      REAL abs5
      REAL abs5d
      REAL abs6
      REAL abs6d
      REAL abs7
      REAL abs7d
      REAL sasum
C     ..
      sasum = 0.0e0
      stemp = 0.0e0
      IF (n .LE. 0 .OR. incx .LE. 0) THEN
        sasum_d = 0.0
        RETURN
      ELSE
        IF (incx .EQ. 1) THEN
C        code for increment equal to 1
C
C
C        clean-up loop
C
          m = MOD(n, 6)
          IF (m .NE. 0) THEN
            stempd = 0.0
            DO i=1,m
              IF (sx(i) .GE. 0.) THEN
                abs0d = sxd(i)
                abs0 = sx(i)
              ELSE
                abs0d = -sxd(i)
                abs0 = -sx(i)
              END IF
              stempd = stempd + abs0d
              stemp = stemp + abs0
            ENDDO
            IF (n .LT. 6) THEN
              sasum_d = stempd
              sasum = stemp
              RETURN
            END IF
          ELSE
            stempd = 0.0
          END IF
          mp1 = m + 1
          DO i=mp1,n,6
            IF (sx(i) .GE. 0.) THEN
              abs1d = sxd(i)
              abs1 = sx(i)
            ELSE
              abs1d = -sxd(i)
              abs1 = -sx(i)
            END IF
            IF (sx(i+1) .GE. 0.) THEN
              abs3d = sxd(i+1)
              abs3 = sx(i+1)
            ELSE
              abs3d = -sxd(i+1)
              abs3 = -sx(i+1)
            END IF
            IF (sx(i+2) .GE. 0.) THEN
              abs4d = sxd(i+2)
              abs4 = sx(i+2)
            ELSE
              abs4d = -sxd(i+2)
              abs4 = -sx(i+2)
            END IF
            IF (sx(i+3) .GE. 0.) THEN
              abs5d = sxd(i+3)
              abs5 = sx(i+3)
            ELSE
              abs5d = -sxd(i+3)
              abs5 = -sx(i+3)
            END IF
            IF (sx(i+4) .GE. 0.) THEN
              abs6d = sxd(i+4)
              abs6 = sx(i+4)
            ELSE
              abs6d = -sxd(i+4)
              abs6 = -sx(i+4)
            END IF
            IF (sx(i+5) .GE. 0.) THEN
              abs7d = sxd(i+5)
              abs7 = sx(i+5)
            ELSE
              abs7d = -sxd(i+5)
              abs7 = -sx(i+5)
            END IF
            stempd = stempd + abs1d + abs3d + abs4d + abs5d + abs6d + 
     +        abs7d
            stemp = stemp + abs1 + abs3 + abs4 + abs5 + abs6 + abs7
          ENDDO
        ELSE
C
C        code for increment not equal to 1
C
          nincx = n*incx
          stempd = 0.0
          DO i=1,nincx,incx
            IF (sx(i) .GE. 0.) THEN
              abs2d = sxd(i)
              abs2 = sx(i)
            ELSE
              abs2d = -sxd(i)
              abs2 = -sx(i)
            END IF
            stempd = stempd + abs2d
            stemp = stemp + abs2
          ENDDO
        END IF
        sasum_d = stempd
        sasum = stemp
        RETURN
C
C     End of SASUM
C
      END IF
      END

