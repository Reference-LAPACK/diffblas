C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of dsyrk in reverse (adjoint) mode:
C   gradient     of useful results: c
C   with respect to varying inputs: alpha beta a c
C   RW status of diff variables: alpha:out beta:out a:out c:in-out
C> \brief \b DSYRK
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       SUBROUTINE DSYRK(UPLO,TRANS,N,K,ALPHA,A,LDA,BETA,C,LDC)
C
C       .. Scalar Arguments ..
C       DOUBLE PRECISION ALPHA,BETA
C       INTEGER K,LDA,LDC,N
C       CHARACTER TRANS,UPLO
C       ..
C       .. Array Arguments ..
C       DOUBLE PRECISION A(LDA,*),C(LDC,*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C> DSYRK  performs one of the symmetric rank k operations
C>
C>    C := alpha*A*A**T + beta*C,
C>
C> or
C>
C>    C := alpha*A**T*A + beta*C,
C>
C> where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
C> and  A  is an  n by k  matrix in the first case and a  k by n  matrix
C> in the second case.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] UPLO
C> \verbatim
C>          UPLO is CHARACTER*1
C>           On  entry,   UPLO  specifies  whether  the  upper  or  lower
C>           triangular  part  of the  array  C  is to be  referenced  as
C>           follows:
C>
C>              UPLO = 'U' or 'u'   Only the  upper triangular part of  C
C>                                  is to be referenced.
C>
C>              UPLO = 'L' or 'l'   Only the  lower triangular part of  C
C>                                  is to be referenced.
C> \endverbatim
C>
C> \param[in] TRANS
C> \verbatim
C>          TRANS is CHARACTER*1
C>           On entry,  TRANS  specifies the operation to be performed as
C>           follows:
C>
C>              TRANS = 'N' or 'n'   C := alpha*A*A**T + beta*C.
C>
C>              TRANS = 'T' or 't'   C := alpha*A**T*A + beta*C.
C>
C>              TRANS = 'C' or 'c'   C := alpha*A**T*A + beta*C.
C> \endverbatim
C>
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>           On entry,  N specifies the order of the matrix C.  N must be
C>           at least zero.
C> \endverbatim
C>
C> \param[in] K
C> \verbatim
C>          K is INTEGER
C>           On entry with  TRANS = 'N' or 'n',  K  specifies  the number
C>           of  columns   of  the   matrix   A,   and  on   entry   with
C>           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
C>           of rows of the matrix  A.  K must be at least zero.
C> \endverbatim
C>
C> \param[in] ALPHA
C> \verbatim
C>          ALPHA is DOUBLE PRECISION.
C>           On entry, ALPHA specifies the scalar alpha.
C> \endverbatim
C>
C> \param[in] A
C> \verbatim
C>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is
C>           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
C>           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
C>           part of the array  A  must contain the matrix  A,  otherwise
C>           the leading  k by n  part of the array  A  must contain  the
C>           matrix A.
C> \endverbatim
C>
C> \param[in] LDA
C> \verbatim
C>          LDA is INTEGER
C>           On entry, LDA specifies the first dimension of A as declared
C>           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
C>           then  LDA must be at least  max( 1, n ), otherwise  LDA must
C>           be at least  max( 1, k ).
C> \endverbatim
C>
C> \param[in] BETA
C> \verbatim
C>          BETA is DOUBLE PRECISION.
C>           On entry, BETA specifies the scalar beta.
C> \endverbatim
C>
C> \param[in,out] C
C> \verbatim
C>          C is DOUBLE PRECISION array, dimension ( LDC, N )
C>           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
C>           upper triangular part of the array C must contain the upper
C>           triangular part  of the  symmetric matrix  and the strictly
C>           lower triangular part of C is not referenced.  On exit, the
C>           upper triangular part of the array  C is overwritten by the
C>           upper triangular part of the updated matrix.
C>           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
C>           lower triangular part of the array C must contain the lower
C>           triangular part  of the  symmetric matrix  and the strictly
C>           upper triangular part of C is not referenced.  On exit, the
C>           lower triangular part of the array  C is overwritten by the
C>           lower triangular part of the updated matrix.
C> \endverbatim
C>
C> \param[in] LDC
C> \verbatim
C>          LDC is INTEGER
C>           On entry, LDC specifies the first dimension of C as declared
C>           in  the  calling  (sub)  program.   LDC  must  be  at  least
C>           max( 1, n ).
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup herk
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>  Level 3 Blas routine.
C>
C>  -- Written on 8-February-1989.
C>     Jack Dongarra, Argonne National Laboratory.
C>     Iain Duff, AERE Harwell.
C>     Jeremy Du Croz, Numerical Algorithms Group Ltd.
C>     Sven Hammarling, Numerical Algorithms Group Ltd.
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE DSYRK_B(uplo, trans, n, k, alpha, alphab, a, ab, lda, 
     +                   beta, betab, c, cb, ldc)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE2OFa should be the size of dimension 2 of array a
C
C  -- Reference BLAS level3 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION alpha, beta
      DOUBLE PRECISION alphab, betab
      INTEGER k, lda, ldc, n
      CHARACTER trans, uplo
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION a(lda, *), c(ldc, *)
      DOUBLE PRECISION ab(lda, *), cb(ldc, *)
      EXTERNAL LSAME
C     ..
C
C  =====================================================================
C
C     .. External Functions ..
      INTEGER get_ISIZE2OFA
      EXTERNAL get_ISIZE2OFA
      LOGICAL LSAME
C     ..
C     .. External Subroutines ..
      EXTERNAL XERBLA, check_ISIZE2OFA_initialized
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION temp
      DOUBLE PRECISION tempb
      INTEGER i, info, j, l, nrowa
      LOGICAL upper
      INTEGER ISIZE2OFA
C     ..
C     .. Parameters ..
      DOUBLE PRECISION one, zero
      PARAMETER (one=1.0d+0, zero=0.0d+0)
      INTEGER max1
      INTEGER max2
      INTEGER ad_to
      INTEGER ad_to0
      INTEGER ad_from
      INTEGER ad_from0
      INTEGER ad_to1
      INTEGER ad_to2
      INTEGER ad_to3
      INTEGER*4 branch
      INTEGER ad_from1
      INTEGER ad_from2
      INTEGER ad_from3
      INTEGER ad_to4
      INTEGER ad_from4
      INTEGER ii2
      INTEGER ii1
C     ..
C
C     Test the input parameters.
C
      CALL check_ISIZE2OFA_initialized()
      ISIZE2OFA = get_ISIZE2OFA()
      IF (LSAME(trans, 'N')) THEN
        nrowa = n
      ELSE
        nrowa = k
      END IF
      upper = LSAME(uplo, 'U')
C
      info = 0
      IF (.NOT.upper .AND. (.NOT.LSAME(uplo, 'L'))) THEN
        CALL PUSHCONTROL3B(0)
        info = 1
      ELSE IF (.NOT.LSAME(trans, 'N') .AND. (.NOT.LSAME(trans, 'T')) 
     +    .AND. (.NOT.LSAME(trans, 'C'))) THEN
        CALL PUSHCONTROL3B(1)
        info = 2
      ELSE IF (n .LT. 0) THEN
        CALL PUSHCONTROL3B(2)
        info = 3
      ELSE IF (k .LT. 0) THEN
        CALL PUSHCONTROL3B(3)
        info = 4
      ELSE
        IF (1 .LT. nrowa) THEN
          max1 = nrowa
        ELSE
          max1 = 1
        END IF
        IF (lda .LT. max1) THEN
          CALL PUSHCONTROL3B(4)
          info = 7
        ELSE
          IF (1 .LT. n) THEN
            max2 = n
          ELSE
            max2 = 1
          END IF
          IF (ldc .LT. max2) THEN
            CALL PUSHCONTROL3B(5)
            info = 10
          ELSE
            CALL PUSHCONTROL3B(5)
          END IF
        END IF
      END IF
      IF (info .EQ. 0) THEN
C
C     Quick return if possible.
C
        IF (n .EQ. 0 .OR. ((alpha .EQ. zero .OR. k .EQ. 0) .AND. beta 
     +      .EQ. one)) THEN
          alphab = 0.D0
          betab = 0.D0
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              ab(ii2, ii1) = 0.D0
            ENDDO
          ENDDO
        ELSE IF (alpha .EQ. zero) THEN
C
C     And when  alpha.eq.zero.
C
          IF (upper) THEN
            IF (beta .EQ. zero) THEN
              DO j=1,n
                i = j + 1
                CALL PUSHINTEGER4(i - 1)
              ENDDO
              DO j=n,1,-1
                CALL POPINTEGER4(ad_to)
                DO i=ad_to,1,-1
                  cb(i, j) = 0.D0
                ENDDO
              ENDDO
              betab = 0.D0
            ELSE
              DO j=1,n
                i = j + 1
                CALL PUSHINTEGER4(i - 1)
              ENDDO
              betab = 0.D0
              DO j=n,1,-1
                CALL POPINTEGER4(ad_to0)
                DO i=ad_to0,1,-1
                  betab = betab + c(i, j)*cb(i, j)
                  cb(i, j) = beta*cb(i, j)
                ENDDO
              ENDDO
            END IF
          ELSE IF (beta .EQ. zero) THEN
            DO j=1,n
              ad_from = j
              CALL PUSHINTEGER4(ad_from)
            ENDDO
            DO j=n,1,-1
              CALL POPINTEGER4(ad_from)
              DO i=n,ad_from,-1
                cb(i, j) = 0.D0
              ENDDO
            ENDDO
            betab = 0.D0
          ELSE
            DO j=1,n
              ad_from0 = j
              CALL PUSHINTEGER4(ad_from0)
            ENDDO
            betab = 0.D0
            DO j=n,1,-1
              CALL POPINTEGER4(ad_from0)
              DO i=n,ad_from0,-1
                betab = betab + c(i, j)*cb(i, j)
                cb(i, j) = beta*cb(i, j)
              ENDDO
            ENDDO
          END IF
          alphab = 0.D0
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              ab(ii2, ii1) = 0.D0
            ENDDO
          ENDDO
        ELSE IF (LSAME(trans, 'N')) THEN
C
C     Start the operations.
C
C
C        Form  C := alpha*A*A**T + beta*C.
C
          IF (upper) THEN
            DO j=1,n
              IF (beta .EQ. zero) THEN
                i = j + 1
                CALL PUSHINTEGER4(i - 1)
                CALL PUSHCONTROL2B(2)
              ELSE IF (beta .NE. one) THEN
                i = j + 1
                CALL PUSHINTEGER4(i - 1)
                CALL PUSHCONTROL2B(1)
              ELSE
                CALL PUSHCONTROL2B(0)
              END IF
              DO l=1,k
                IF (a(j, l) .NE. zero) THEN
                  CALL PUSHREAL8(temp)
                  temp = alpha*a(j, l)
                  i = j + 1
                  CALL PUSHINTEGER4(i - 1)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
            ENDDO
            alphab = 0.D0
            betab = 0.D0
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                ab(ii2, ii1) = 0.D0
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO l=k,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  tempb = 0.D0
                  CALL POPINTEGER4(ad_to3)
                  DO i=ad_to3,1,-1
                    tempb = tempb + a(i, l)*cb(i, j)
                    ab(i, l) = ab(i, l) + temp*cb(i, j)
                  ENDDO
                  CALL POPREAL8(temp)
                  alphab = alphab + a(j, l)*tempb
                  ab(j, l) = ab(j, l) + alpha*tempb
                END IF
              ENDDO
              CALL POPCONTROL2B(branch)
              IF (branch .NE. 0) THEN
                IF (branch .EQ. 1) THEN
                  CALL POPINTEGER4(ad_to2)
                  DO i=ad_to2,1,-1
                    betab = betab + c(i, j)*cb(i, j)
                    cb(i, j) = beta*cb(i, j)
                  ENDDO
                ELSE
                  CALL POPINTEGER4(ad_to1)
                  DO i=ad_to1,1,-1
                    cb(i, j) = 0.D0
                  ENDDO
                END IF
              END IF
            ENDDO
          ELSE
            DO j=1,n
              IF (beta .EQ. zero) THEN
                ad_from1 = j
                CALL PUSHINTEGER4(ad_from1)
                CALL PUSHCONTROL2B(2)
              ELSE IF (beta .NE. one) THEN
                ad_from2 = j
                CALL PUSHINTEGER4(ad_from2)
                CALL PUSHCONTROL2B(1)
              ELSE
                CALL PUSHCONTROL2B(0)
              END IF
              DO l=1,k
                IF (a(j, l) .NE. zero) THEN
                  CALL PUSHREAL8(temp)
                  temp = alpha*a(j, l)
                  ad_from3 = j
                  CALL PUSHINTEGER4(ad_from3)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
            ENDDO
            alphab = 0.D0
            betab = 0.D0
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                ab(ii2, ii1) = 0.D0
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO l=k,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  tempb = 0.D0
                  CALL POPINTEGER4(ad_from3)
                  DO i=n,ad_from3,-1
                    tempb = tempb + a(i, l)*cb(i, j)
                    ab(i, l) = ab(i, l) + temp*cb(i, j)
                  ENDDO
                  CALL POPREAL8(temp)
                  alphab = alphab + a(j, l)*tempb
                  ab(j, l) = ab(j, l) + alpha*tempb
                END IF
              ENDDO
              CALL POPCONTROL2B(branch)
              IF (branch .NE. 0) THEN
                IF (branch .EQ. 1) THEN
                  CALL POPINTEGER4(ad_from2)
                  DO i=n,ad_from2,-1
                    betab = betab + c(i, j)*cb(i, j)
                    cb(i, j) = beta*cb(i, j)
                  ENDDO
                ELSE
                  CALL POPINTEGER4(ad_from1)
                  DO i=n,ad_from1,-1
                    cb(i, j) = 0.D0
                  ENDDO
                END IF
              END IF
            ENDDO
          END IF
        ELSE IF (upper) THEN
C
C        Form  C := alpha*A**T*A + beta*C.
C
          DO j=1,n
            DO i=1,j
              CALL PUSHREAL8(temp)
              temp = zero
              DO l=1,k
                temp = temp + a(l, i)*a(l, j)
              ENDDO
              IF (beta .EQ. zero) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            ENDDO
            CALL PUSHINTEGER4(i - 1)
          ENDDO
          alphab = 0.D0
          betab = 0.D0
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              ab(ii2, ii1) = 0.D0
            ENDDO
          ENDDO
          DO j=n,1,-1
            CALL POPINTEGER4(ad_to4)
            DO i=ad_to4,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                alphab = alphab + temp*cb(i, j)
                tempb = alpha*cb(i, j)
                cb(i, j) = 0.D0
              ELSE
                alphab = alphab + temp*cb(i, j)
                tempb = alpha*cb(i, j)
                betab = betab + c(i, j)*cb(i, j)
                cb(i, j) = beta*cb(i, j)
              END IF
              DO l=k,1,-1
                ab(l, i) = ab(l, i) + a(l, j)*tempb
                ab(l, j) = ab(l, j) + a(l, i)*tempb
              ENDDO
              CALL POPREAL8(temp)
            ENDDO
          ENDDO
        ELSE
          DO j=1,n
            ad_from4 = j
            DO i=ad_from4,n
              CALL PUSHREAL8(temp)
              temp = zero
              DO l=1,k
                temp = temp + a(l, i)*a(l, j)
              ENDDO
              IF (beta .EQ. zero) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            ENDDO
            CALL PUSHINTEGER4(ad_from4)
          ENDDO
          alphab = 0.D0
          betab = 0.D0
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              ab(ii2, ii1) = 0.D0
            ENDDO
          ENDDO
          DO j=n,1,-1
            CALL POPINTEGER4(ad_from4)
            DO i=n,ad_from4,-1
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                alphab = alphab + temp*cb(i, j)
                tempb = alpha*cb(i, j)
                cb(i, j) = 0.D0
              ELSE
                alphab = alphab + temp*cb(i, j)
                tempb = alpha*cb(i, j)
                betab = betab + c(i, j)*cb(i, j)
                cb(i, j) = beta*cb(i, j)
              END IF
              DO l=k,1,-1
                ab(l, i) = ab(l, i) + a(l, j)*tempb
                ab(l, j) = ab(l, j) + a(l, i)*tempb
              ENDDO
              CALL POPREAL8(temp)
            ENDDO
          ENDDO
        END IF
      END IF
      CALL POPCONTROL3B(branch)
      END

