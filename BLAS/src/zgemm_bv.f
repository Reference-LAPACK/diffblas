C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) -  6 Jan 2026 19:07
C
C  Differentiation of zgemm in reverse (adjoint) mode (with options multiDirectional):
C   gradient     of useful results: c
C   with respect to varying inputs: alpha beta a b c
C   RW status of diff variables: alpha:out beta:out a:out b:out
C                c:in-out
C> \brief \b ZGEMM
C
C  =========== DOCUMENTATION ===========
C
C Online html documentation available at
C            http://www.netlib.org/lapack/explore-html/
C
C  Definition:
C  ===========
C
C       SUBROUTINE ZGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
C
C       .. Scalar Arguments ..
C       COMPLEX*16 ALPHA,BETA
C       INTEGER K,LDA,LDB,LDC,M,N
C       CHARACTER TRANSA,TRANSB
C       ..
C       .. Array Arguments ..
C       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*)
C       ..
C
C
C> \par Purpose:
C  =============
C>
C> \verbatim
C>
C> ZGEMM  performs one of the matrix-matrix operations
C>
C>    C := alpha*op( A )*op( B ) + beta*C,
C>
C> where  op( X ) is one of
C>
C>    op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H,
C>
C> alpha and beta are scalars, and A, B and C are matrices, with op( A )
C> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
C> \endverbatim
C
C  Arguments:
C  ==========
C
C> \param[in] TRANSA
C> \verbatim
C>          TRANSA is CHARACTER*1
C>           On entry, TRANSA specifies the form of op( A ) to be used in
C>           the matrix multiplication as follows:
C>
C>              TRANSA = 'N' or 'n',  op( A ) = A.
C>
C>              TRANSA = 'T' or 't',  op( A ) = A**T.
C>
C>              TRANSA = 'C' or 'c',  op( A ) = A**H.
C> \endverbatim
C>
C> \param[in] TRANSB
C> \verbatim
C>          TRANSB is CHARACTER*1
C>           On entry, TRANSB specifies the form of op( B ) to be used in
C>           the matrix multiplication as follows:
C>
C>              TRANSB = 'N' or 'n',  op( B ) = B.
C>
C>              TRANSB = 'T' or 't',  op( B ) = B**T.
C>
C>              TRANSB = 'C' or 'c',  op( B ) = B**H.
C> \endverbatim
C>
C> \param[in] M
C> \verbatim
C>          M is INTEGER
C>           On entry,  M  specifies  the number  of rows  of the  matrix
C>           op( A )  and of the  matrix  C.  M  must  be at least  zero.
C> \endverbatim
C>
C> \param[in] N
C> \verbatim
C>          N is INTEGER
C>           On entry,  N  specifies the number  of columns of the matrix
C>           op( B ) and the number of columns of the matrix C. N must be
C>           at least zero.
C> \endverbatim
C>
C> \param[in] K
C> \verbatim
C>          K is INTEGER
C>           On entry,  K  specifies  the number of columns of the matrix
C>           op( A ) and the number of rows of the matrix op( B ). K must
C>           be at least  zero.
C> \endverbatim
C>
C> \param[in] ALPHA
C> \verbatim
C>          ALPHA is COMPLEX*16
C>           On entry, ALPHA specifies the scalar alpha.
C> \endverbatim
C>
C> \param[in] A
C> \verbatim
C>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is
C>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
C>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
C>           part of the array  A  must contain the matrix  A,  otherwise
C>           the leading  k by m  part of the array  A  must contain  the
C>           matrix A.
C> \endverbatim
C>
C> \param[in] LDA
C> \verbatim
C>          LDA is INTEGER
C>           On entry, LDA specifies the first dimension of A as declared
C>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
C>           LDA must be at least  max( 1, m ), otherwise  LDA must be at
C>           least  max( 1, k ).
C> \endverbatim
C>
C> \param[in] B
C> \verbatim
C>          B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is
C>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
C>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
C>           part of the array  B  must contain the matrix  B,  otherwise
C>           the leading  n by k  part of the array  B  must contain  the
C>           matrix B.
C> \endverbatim
C>
C> \param[in] LDB
C> \verbatim
C>          LDB is INTEGER
C>           On entry, LDB specifies the first dimension of B as declared
C>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
C>           LDB must be at least  max( 1, k ), otherwise  LDB must be at
C>           least  max( 1, n ).
C> \endverbatim
C>
C> \param[in] BETA
C> \verbatim
C>          BETA is COMPLEX*16
C>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
C>           supplied as zero then C need not be set on input.
C> \endverbatim
C>
C> \param[in,out] C
C> \verbatim
C>          C is COMPLEX*16 array, dimension ( LDC, N )
C>           Before entry, the leading  m by n  part of the array  C must
C>           contain the matrix  C,  except when  beta  is zero, in which
C>           case C need not be set on entry.
C>           On exit, the array  C  is overwritten by the  m by n  matrix
C>           ( alpha*op( A )*op( B ) + beta*C ).
C> \endverbatim
C>
C> \param[in] LDC
C> \verbatim
C>          LDC is INTEGER
C>           On entry, LDC specifies the first dimension of C as declared
C>           in  the  calling  (sub)  program.   LDC  must  be  at  least
C>           max( 1, m ).
C> \endverbatim
C
C  Authors:
C  ========
C
C> \author Univ. of Tennessee
C> \author Univ. of California Berkeley
C> \author Univ. of Colorado Denver
C> \author NAG Ltd.
C
C> \ingroup gemm
C
C> \par Further Details:
C  =====================
C>
C> \verbatim
C>
C>  Level 3 Blas routine.
C>
C>  -- Written on 8-February-1989.
C>     Jack Dongarra, Argonne National Laboratory.
C>     Iain Duff, AERE Harwell.
C>     Jeremy Du Croz, Numerical Algorithms Group Ltd.
C>     Sven Hammarling, Numerical Algorithms Group Ltd.
C> \endverbatim
C>
C  =====================================================================
      SUBROUTINE ZGEMM_BV(transa, transb, m, n, k, alpha, alphab, a, ab
     +                    , lda, b, bb, ldb, beta, betab, c, cb, ldc, 
     +                    nbdirs)
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE2OFb should be the size of dimension 2 of array b
C  Hint: ISIZE2OFa should be the size of dimension 2 of array a
C  Hint: nbdirsmax should be the maximum number of differentiation directions
C
C  -- Reference BLAS level3 routine --
C  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
C  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
C
C     .. Scalar Arguments ..
      COMPLEX*16 alpha, beta
      COMPLEX*16 alphab(nbdirsmax), betab(nbdirsmax)
      INTEGER k, lda, ldb, ldc, m, n
      CHARACTER transa, transb
C     ..
C     .. Array Arguments ..
      COMPLEX*16 a(lda, *), b(ldb, *), c(ldc, *)
      COMPLEX*16 ab(nbdirsmax, lda, *), bb(nbdirsmax, ldb, *), cb(
     +           nbdirsmax, ldc, *)
      EXTERNAL LSAME
C     ..
C
C  =====================================================================
C
C     .. External Functions ..
      INTEGER get_ISIZE2OFA, get_ISIZE2OFB
      EXTERNAL get_ISIZE2OFA, get_ISIZE2OFB
      LOGICAL LSAME
C     ..
C     .. External Subroutines ..
      EXTERNAL XERBLA, check_ISIZE2OFA_initialized, check_ISIZE2OFB_initialized
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DCONJG, MAX
C     ..
C     .. Local Scalars ..
      COMPLEX*16 temp
      COMPLEX*16 tempb(nbdirsmax)
      INTEGER i, info, j, l, nrowa, nrowb
      LOGICAL conja, conjb, nota, notb
      INTEGER ISIZE2OFA, ISIZE2OFB
C     ..
C     .. Parameters ..
      COMPLEX*16 one
      PARAMETER (one=(1.0d+0,0.0d+0))
      COMPLEX*16 zero
      PARAMETER (zero=(0.0d+0,0.0d+0))
      INTEGER max1
      INTEGER max2
      INTEGER max3
      INTEGER nd
      INTEGER*4 branch
      INTEGER ii2
      INTEGER ii1
      INTEGER nbdirs
C     ..
C
C     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
C     conjugated or transposed, set  CONJA and CONJB  as true if  A  and
C     B  respectively are to be  transposed but  not conjugated  and set
C     NROWA and NROWB  as the number of rows  of  A  and  B  respectively.
C
C     Check 0 < nbdirs <= nbdirsmax (required by DIFFSIZES.inc)
      CALL check_ISIZE2OFA_initialized()
      CALL check_ISIZE2OFB_initialized()
      ISIZE2OFA = get_ISIZE2OFA()
      ISIZE2OFB = get_ISIZE2OFB()
      IF (nbdirs.LE.0 .OR. nbdirs.GT.nbdirsmax) THEN
        WRITE(*,'(A,I0,A,I0,A)') 'Error: nbdirs=', nbdirs,
     +  ' must be in 1..nbdirsmax=', nbdirsmax, '. Stopping.'
        STOP 1
      END IF
C
      nota = LSAME(transa, 'N')
      notb = LSAME(transb, 'N')
      conja = LSAME(transa, 'C')
      conjb = LSAME(transb, 'C')
      IF (nota) THEN
        nrowa = m
      ELSE
        nrowa = k
      END IF
      IF (notb) THEN
        nrowb = k
      ELSE
        nrowb = n
      END IF
C
C     Test the input parameters.
C
      info = 0
      IF (.NOT.nota .AND. (.NOT.conja) .AND. (.NOT.LSAME(transa, 'T'))) 
     +THEN
        CALL PUSHCONTROL3B(0)
        info = 1
      ELSE IF (.NOT.notb .AND. (.NOT.conjb) .AND. (.NOT.LSAME(transb, 
     +    'T'))) THEN
        CALL PUSHCONTROL3B(1)
        info = 2
      ELSE IF (m .LT. 0) THEN
        CALL PUSHCONTROL3B(2)
        info = 3
      ELSE IF (n .LT. 0) THEN
        CALL PUSHCONTROL3B(3)
        info = 4
      ELSE IF (k .LT. 0) THEN
        CALL PUSHCONTROL3B(4)
        info = 5
      ELSE
        IF (1 .LT. nrowa) THEN
          max1 = nrowa
        ELSE
          max1 = 1
        END IF
        IF (lda .LT. max1) THEN
          CALL PUSHCONTROL3B(5)
          info = 8
        ELSE
          IF (1 .LT. nrowb) THEN
            max2 = nrowb
          ELSE
            max2 = 1
          END IF
          IF (ldb .LT. max2) THEN
            CALL PUSHCONTROL3B(6)
            info = 10
          ELSE
            IF (1 .LT. m) THEN
              max3 = m
            ELSE
              max3 = 1
            END IF
            IF (ldc .LT. max3) THEN
              CALL PUSHCONTROL3B(7)
              info = 13
            ELSE
              CALL PUSHCONTROL3B(7)
            END IF
          END IF
        END IF
      END IF
      IF (info .EQ. 0) THEN
C
C     Quick return if possible.
C
        IF ((m .EQ. 0 .OR. n .EQ. 0) .OR. ((alpha .EQ. zero .OR. k .EQ. 
     +      0) .AND. beta .EQ. one)) THEN
          DO nd=1,nbdirsmax
            alphab(nd) = (0.0,0.0)
          ENDDO
          DO nd=1,nbdirsmax
            betab(nd) = (0.0,0.0)
          ENDDO
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              DO nd=1,nbdirsmax
                ab(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
          DO ii1=1,ISIZE2OFb
            DO ii2=1,ldb
              DO nd=1,nbdirsmax
                bb(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
        ELSE IF (alpha .EQ. zero) THEN
C
C     And when  alpha.eq.zero.
C
          IF (beta .EQ. zero) THEN
            DO j=n,1,-1
              DO i=m,1,-1
                DO nd=1,nbdirs
                  cb(nd, i, j) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
          ELSE
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
            DO j=n,1,-1
              DO i=m,1,-1
                DO nd=1,nbdirs
                  betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j)
                  cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                ENDDO
              ENDDO
            ENDDO
          END IF
          DO nd=1,nbdirsmax
            alphab(nd) = (0.0,0.0)
          ENDDO
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              DO nd=1,nbdirsmax
                ab(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
          DO ii1=1,ISIZE2OFb
            DO ii2=1,ldb
              DO nd=1,nbdirsmax
                bb(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
        ELSE IF (notb) THEN
C
C     Start the operations.
C
          IF (nota) THEN
C
C           Form  C := alpha*A*B + beta*C.
C
            DO j=1,n
              IF (beta .EQ. zero) THEN
                CALL PUSHCONTROL2B(2)
              ELSE IF (beta .NE. one) THEN
                CALL PUSHCONTROL2B(1)
              ELSE
                CALL PUSHCONTROL2B(0)
              END IF
            ENDDO
            DO nd=1,nbdirsmax
              alphab(nd) = (0.0,0.0)
            ENDDO
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                DO nd=1,nbdirsmax
                  bb(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO l=k,1,-1
                temp = alpha*b(l, j)
                DO nd=1,nbdirsmax
                  tempb(nd) = (0.0,0.0)
                ENDDO
                DO i=m,1,-1
                  DO nd=1,nbdirs
                    tempb(nd) = tempb(nd) + CONJG(a(i, l))*cb(nd, i, j)
                    ab(nd, i, l) = ab(nd, i, l) + CONJG(temp)*cb(nd, i, 
     +                j)
                  ENDDO
                ENDDO
                DO nd=1,nbdirs
                  alphab(nd) = alphab(nd) + CONJG(b(l, j))*tempb(nd)
                  bb(nd, l, j) = bb(nd, l, j) + CONJG(alpha)*tempb(nd)
                ENDDO
              ENDDO
              CALL POPCONTROL2B(branch)
              IF (branch .NE. 0) THEN
                IF (branch .EQ. 1) THEN
                  DO i=m,1,-1
                    DO nd=1,nbdirs
                      betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j
     +                  )
                      cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                    ENDDO
                  ENDDO
                ELSE
                  DO i=m,1,-1
                    DO nd=1,nbdirs
                      cb(nd, i, j) = (0.0,0.0)
                    ENDDO
                  ENDDO
                END IF
              END IF
            ENDDO
          ELSE IF (conja) THEN
C
C           Form  C := alpha*A**H*B + beta*C.
C
            DO j=1,n
              DO i=1,m
                CALL PUSHCOMPLEX16(temp)
                temp = zero
                DO l=1,k
                  temp = temp + DCONJG(a(l, i))*b(l, j)
                ENDDO
                IF (beta .EQ. zero) THEN
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
            ENDDO
            DO nd=1,nbdirsmax
              alphab(nd) = (0.0,0.0)
            ENDDO
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                DO nd=1,nbdirsmax
                  bb(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO i=m,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  DO nd=1,nbdirs
                    alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                    tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                    cb(nd, i, j) = (0.0,0.0)
                  ENDDO
                ELSE
                  DO nd=1,nbdirs
                    alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                    tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                    betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j)
                    cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                  ENDDO
                END IF
                DO l=k,1,-1
                  DO nd=1,nbdirs
                    ab(nd, l, i) = ab(nd, l, i) + DCONJG(CONJG(b(l, j))*
     +                tempb(nd))
                    bb(nd, l, j) = bb(nd, l, j) + CONJG(DCONJG(a(l, i)))
     +                *tempb(nd)
                  ENDDO
                ENDDO
                CALL POPCOMPLEX16(temp)
              ENDDO
            ENDDO
          ELSE
C
C           Form  C := alpha*A**T*B + beta*C
C
            DO j=1,n
              DO i=1,m
                CALL PUSHCOMPLEX16(temp)
                temp = zero
                DO l=1,k
                  temp = temp + a(l, i)*b(l, j)
                ENDDO
                IF (beta .EQ. zero) THEN
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
            ENDDO
            DO nd=1,nbdirsmax
              alphab(nd) = (0.0,0.0)
            ENDDO
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                DO nd=1,nbdirsmax
                  bb(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO i=m,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  DO nd=1,nbdirs
                    alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                    tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                    cb(nd, i, j) = (0.0,0.0)
                  ENDDO
                ELSE
                  DO nd=1,nbdirs
                    alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                    tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                    betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j)
                    cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                  ENDDO
                END IF
                DO l=k,1,-1
                  DO nd=1,nbdirs
                    ab(nd, l, i) = ab(nd, l, i) + CONJG(b(l, j))*tempb(
     +                nd)
                    bb(nd, l, j) = bb(nd, l, j) + CONJG(a(l, i))*tempb(
     +                nd)
                  ENDDO
                ENDDO
                CALL POPCOMPLEX16(temp)
              ENDDO
            ENDDO
          END IF
        ELSE IF (nota) THEN
          IF (conjb) THEN
C
C           Form  C := alpha*A*B**H + beta*C.
C
            DO j=1,n
              IF (beta .EQ. zero) THEN
                CALL PUSHCONTROL2B(2)
              ELSE IF (beta .NE. one) THEN
                CALL PUSHCONTROL2B(1)
              ELSE
                CALL PUSHCONTROL2B(0)
              END IF
              DO l=1,k
                CALL PUSHCOMPLEX16(temp)
                temp = alpha*DCONJG(b(j, l))
              ENDDO
            ENDDO
            DO nd=1,nbdirsmax
              alphab(nd) = (0.0,0.0)
            ENDDO
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                DO nd=1,nbdirsmax
                  bb(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO l=k,1,-1
                DO nd=1,nbdirsmax
                  tempb(nd) = (0.0,0.0)
                ENDDO
                DO i=m,1,-1
                  DO nd=1,nbdirs
                    tempb(nd) = tempb(nd) + CONJG(a(i, l))*cb(nd, i, j)
                    ab(nd, i, l) = ab(nd, i, l) + CONJG(temp)*cb(nd, i, 
     +                j)
                  ENDDO
                ENDDO
                CALL POPCOMPLEX16(temp)
                DO nd=1,nbdirs
                  alphab(nd) = alphab(nd) + CONJG(DCONJG(b(j, l)))*tempb
     +              (nd)
                  bb(nd, j, l) = bb(nd, j, l) + DCONJG(CONJG(alpha)*
     +              tempb(nd))
                ENDDO
              ENDDO
              CALL POPCONTROL2B(branch)
              IF (branch .NE. 0) THEN
                IF (branch .EQ. 1) THEN
                  DO i=m,1,-1
                    DO nd=1,nbdirs
                      betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j
     +                  )
                      cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                    ENDDO
                  ENDDO
                ELSE
                  DO i=m,1,-1
                    DO nd=1,nbdirs
                      cb(nd, i, j) = (0.0,0.0)
                    ENDDO
                  ENDDO
                END IF
              END IF
            ENDDO
          ELSE
C
C           Form  C := alpha*A*B**T + beta*C
C
            DO j=1,n
              IF (beta .EQ. zero) THEN
                CALL PUSHCONTROL2B(2)
              ELSE IF (beta .NE. one) THEN
                CALL PUSHCONTROL2B(1)
              ELSE
                CALL PUSHCONTROL2B(0)
              END IF
            ENDDO
            DO nd=1,nbdirsmax
              alphab(nd) = (0.0,0.0)
            ENDDO
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                DO nd=1,nbdirsmax
                  bb(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO l=k,1,-1
                temp = alpha*b(j, l)
                DO nd=1,nbdirsmax
                  tempb(nd) = (0.0,0.0)
                ENDDO
                DO i=m,1,-1
                  DO nd=1,nbdirs
                    tempb(nd) = tempb(nd) + CONJG(a(i, l))*cb(nd, i, j)
                    ab(nd, i, l) = ab(nd, i, l) + CONJG(temp)*cb(nd, i, 
     +                j)
                  ENDDO
                ENDDO
                DO nd=1,nbdirs
                  alphab(nd) = alphab(nd) + CONJG(b(j, l))*tempb(nd)
                  bb(nd, j, l) = bb(nd, j, l) + CONJG(alpha)*tempb(nd)
                ENDDO
              ENDDO
              CALL POPCONTROL2B(branch)
              IF (branch .NE. 0) THEN
                IF (branch .EQ. 1) THEN
                  DO i=m,1,-1
                    DO nd=1,nbdirs
                      betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j
     +                  )
                      cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                    ENDDO
                  ENDDO
                ELSE
                  DO i=m,1,-1
                    DO nd=1,nbdirs
                      cb(nd, i, j) = (0.0,0.0)
                    ENDDO
                  ENDDO
                END IF
              END IF
            ENDDO
          END IF
        ELSE IF (conja) THEN
          IF (conjb) THEN
C
C           Form  C := alpha*A**H*B**H + beta*C.
C
            DO j=1,n
              DO i=1,m
                CALL PUSHCOMPLEX16(temp)
                temp = zero
                DO l=1,k
                  temp = temp + DCONJG(a(l, i))*DCONJG(b(j, l))
                ENDDO
                IF (beta .EQ. zero) THEN
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
            ENDDO
            DO nd=1,nbdirsmax
              alphab(nd) = (0.0,0.0)
            ENDDO
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                DO nd=1,nbdirsmax
                  bb(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO i=m,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  DO nd=1,nbdirs
                    alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                    tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                    cb(nd, i, j) = (0.0,0.0)
                  ENDDO
                ELSE
                  DO nd=1,nbdirs
                    alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                    tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                    betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j)
                    cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                  ENDDO
                END IF
                DO l=k,1,-1
                  DO nd=1,nbdirs
                    ab(nd, l, i) = ab(nd, l, i) + DCONJG(CONJG(DCONJG(b(
     +                j, l)))*tempb(nd))
                    bb(nd, j, l) = bb(nd, j, l) + DCONJG(CONJG(DCONJG(a(
     +                l, i)))*tempb(nd))
                  ENDDO
                ENDDO
                CALL POPCOMPLEX16(temp)
              ENDDO
            ENDDO
          ELSE
C
C           Form  C := alpha*A**H*B**T + beta*C
C
            DO j=1,n
              DO i=1,m
                CALL PUSHCOMPLEX16(temp)
                temp = zero
                DO l=1,k
                  temp = temp + DCONJG(a(l, i))*b(j, l)
                ENDDO
                IF (beta .EQ. zero) THEN
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
              ENDDO
            ENDDO
            DO nd=1,nbdirsmax
              alphab(nd) = (0.0,0.0)
            ENDDO
            DO nd=1,nbdirsmax
              betab(nd) = (0.0,0.0)
            ENDDO
            DO ii1=1,ISIZE2OFa
              DO ii2=1,lda
                DO nd=1,nbdirsmax
                  ab(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO ii1=1,ISIZE2OFb
              DO ii2=1,ldb
                DO nd=1,nbdirsmax
                  bb(nd, ii2, ii1) = (0.0,0.0)
                ENDDO
              ENDDO
            ENDDO
            DO j=n,1,-1
              DO i=m,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  DO nd=1,nbdirs
                    alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                    tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                    cb(nd, i, j) = (0.0,0.0)
                  ENDDO
                ELSE
                  DO nd=1,nbdirs
                    alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                    tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                    betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j)
                    cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                  ENDDO
                END IF
                DO l=k,1,-1
                  DO nd=1,nbdirs
                    ab(nd, l, i) = ab(nd, l, i) + DCONJG(CONJG(b(j, l))*
     +                tempb(nd))
                    bb(nd, j, l) = bb(nd, j, l) + CONJG(DCONJG(a(l, i)))
     +                *tempb(nd)
                  ENDDO
                ENDDO
                CALL POPCOMPLEX16(temp)
              ENDDO
            ENDDO
          END IF
        ELSE IF (conjb) THEN
C
C           Form  C := alpha*A**T*B**H + beta*C
C
          DO j=1,n
            DO i=1,m
              CALL PUSHCOMPLEX16(temp)
              temp = zero
              DO l=1,k
                temp = temp + a(l, i)*DCONJG(b(j, l))
              ENDDO
              IF (beta .EQ. zero) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            ENDDO
          ENDDO
          DO nd=1,nbdirsmax
            alphab(nd) = (0.0,0.0)
          ENDDO
          DO nd=1,nbdirsmax
            betab(nd) = (0.0,0.0)
          ENDDO
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              DO nd=1,nbdirsmax
                ab(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
          DO ii1=1,ISIZE2OFb
            DO ii2=1,ldb
              DO nd=1,nbdirsmax
                bb(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
          DO j=n,1,-1
            DO i=m,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                DO nd=1,nbdirs
                  alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                  tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                  cb(nd, i, j) = (0.0,0.0)
                ENDDO
              ELSE
                DO nd=1,nbdirs
                  alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                  tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                  betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j)
                  cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                ENDDO
              END IF
              DO l=k,1,-1
                DO nd=1,nbdirs
                  ab(nd, l, i) = ab(nd, l, i) + CONJG(DCONJG(b(j, l)))*
     +              tempb(nd)
                  bb(nd, j, l) = bb(nd, j, l) + DCONJG(CONJG(a(l, i))*
     +              tempb(nd))
                ENDDO
              ENDDO
              CALL POPCOMPLEX16(temp)
            ENDDO
          ENDDO
        ELSE
C
C           Form  C := alpha*A**T*B**T + beta*C
C
          DO j=1,n
            DO i=1,m
              CALL PUSHCOMPLEX16(temp)
              temp = zero
              DO l=1,k
                temp = temp + a(l, i)*b(j, l)
              ENDDO
              IF (beta .EQ. zero) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            ENDDO
          ENDDO
          DO nd=1,nbdirsmax
            alphab(nd) = (0.0,0.0)
          ENDDO
          DO nd=1,nbdirsmax
            betab(nd) = (0.0,0.0)
          ENDDO
          DO ii1=1,ISIZE2OFa
            DO ii2=1,lda
              DO nd=1,nbdirsmax
                ab(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
          DO ii1=1,ISIZE2OFb
            DO ii2=1,ldb
              DO nd=1,nbdirsmax
                bb(nd, ii2, ii1) = (0.0,0.0)
              ENDDO
            ENDDO
          ENDDO
          DO j=n,1,-1
            DO i=m,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                DO nd=1,nbdirs
                  alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                  tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                  cb(nd, i, j) = (0.0,0.0)
                ENDDO
              ELSE
                DO nd=1,nbdirs
                  alphab(nd) = alphab(nd) + CONJG(temp)*cb(nd, i, j)
                  tempb(nd) = CONJG(alpha)*cb(nd, i, j)
                  betab(nd) = betab(nd) + CONJG(c(i, j))*cb(nd, i, j)
                  cb(nd, i, j) = CONJG(beta)*cb(nd, i, j)
                ENDDO
              END IF
              DO l=k,1,-1
                DO nd=1,nbdirs
                  ab(nd, l, i) = ab(nd, l, i) + CONJG(b(j, l))*tempb(nd)
                  bb(nd, j, l) = bb(nd, j, l) + CONJG(a(l, i))*tempb(nd)
                ENDDO
              ENDDO
              CALL POPCOMPLEX16(temp)
            ENDDO
          ENDDO
        END IF
      END IF
      CALL POPCONTROL3B(branch)
      END

